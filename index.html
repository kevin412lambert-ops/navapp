<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Road Trip Telemetry</title>

    <!-- MapLibre GL JS CSS -->
    <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e5e5e5;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            color: white;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .header .subtitle {
            font-size: 14px;
            opacity: 0.9;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 15px;
            gap: 15px;
        }

        /* Telemetry Cards */
        .telemetry-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .telemetry-card {
            background: #2d2d2d;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .telemetry-card.full-width {
            grid-column: 1 / -1;
        }

        .telemetry-label {
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .telemetry-value {
            font-size: 28px;
            font-weight: 700;
            color: #f97316;
            line-height: 1;
        }

        .telemetry-value.large {
            font-size: 36px;
        }

        .telemetry-unit {
            font-size: 16px;
            color: #666;
            margin-left: 4px;
        }

        .telemetry-secondary {
            font-size: 14px;
            color: #999;
            margin-top: 8px;
        }

        /* Heading Arrow */
        .heading-arrow {
            display: inline-block;
            width: 40px;
            height: 40px;
            margin-left: 12px;
            vertical-align: middle;
            transition: transform 0.5s ease-out, opacity 0.3s ease;
        }

        .heading-arrow svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        /* Wind Arrow */
        .wind-arrow {
            display: inline-block;
            width: 40px;
            height: 40px;
            margin-left: 12px;
            vertical-align: middle;
            transition: transform 0.5s ease-out, opacity 0.3s ease;
        }

        .wind-arrow svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        /* Map Section */
        .map-section {
            position: relative;
            background: #2d2d2d;
            border-radius: 12px;
            overflow: hidden;
            height: 250px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Exits List */
        .exits-section {
            background: #2d2d2d;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .exits-header {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #f97316;
        }

        .exit-item {
            background: #3a3a3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .exit-item:last-child {
            margin-bottom: 0;
        }

        .exit-name {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .exit-meta {
            font-size: 12px;
            color: #999;
            display: flex;
            gap: 12px;
        }

        .no-data {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 14px;
        }

        /* Status Indicator */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .status-indicator.active {
            background: #10b981;
            box-shadow: 0 0 8px #10b981;
            animation: pulse 2s infinite;
        }

        .status-indicator.waiting {
            background: #f59e0b;
        }

        .status-indicator.error {
            background: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Overpass Alert Styles */
        .overpass-alert {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideDown 0.3s ease-out;
            max-width: 400px;
            text-align: center;
        }

        .overpass-alert.normal {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: 2px solid #2d6ca8;
        }

        .overpass-alert.warning {
            background: linear-gradient(135deg, #ff9500, #ff6b00);
            color: white;
            border: 2px solid #cc5200;
        }

        .overpass-alert.danger {
            background: linear-gradient(135deg, #ff3b30, #cc0000);
            color: white;
            border: 2px solid #990000;
            animation: pulseAlert 1s ease-in-out infinite;
        }

        .overpass-alert-title {
            font-size: 18px;
            margin-bottom: 5px;
        }

        .overpass-alert-details {
            font-size: 14px;
            font-weight: normal;
            opacity: 0.9;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        @keyframes pulseAlert {
            0%, 100% {
                transform: translateX(-50%) scale(1);
            }
            50% {
                transform: translateX(-50%) scale(1.02);
            }
        }

        /* Compass Styles */
        .compass-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .compass-circle {
            position: relative;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, #3a3a3a, #2a2a2a);
            border: 3px solid #f97316;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }

        .compass-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform-origin: 50% 50%;
            transition: transform 0.3s ease;
        }

        .compass-arrow::before {
            content: '';
            position: absolute;
            top: -30px;
            left: -4px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 30px solid #ef4444;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.4));
        }

        .compass-arrow::after {
            content: '';
            position: absolute;
            top: 0;
            left: -3px;
            width: 0;
            height: 0;
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-top: 20px solid #666;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.4));
        }

        .compass-cardinal {
            position: absolute;
            font-size: 11px;
            font-weight: bold;
            color: #f97316;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .compass-cardinal.n {
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-cardinal.e {
            top: 50%;
            right: 6px;
            transform: translateY(-50%);
        }

        .compass-cardinal.s {
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-cardinal.w {
            top: 50%;
            left: 6px;
            transform: translateY(-50%);
        }

        /* Rain Animation Styles */
        .rain-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            display: none;
            z-index: 500;
        }

        .rain-overlay.active {
            display: block;
        }

        .raindrop {
            position: absolute;
            width: 2px;
            height: 15px;
            background: linear-gradient(transparent, rgba(174, 194, 224, 0.5));
            animation: fall linear infinite;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh);
            }
        }

        /* Search Box */
        .search-box {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            background: #2d2d2d;
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            padding: 10px 15px;
            color: #666;
            font-size: 14px;
            cursor: not-allowed;
        }

        .search-box::placeholder {
            color: #666;
            opacity: 1;
        }

        .search-box:disabled {
            background: #2d2d2d;
            color: #666;
        }

        /* Coordinates Display */
        .map-coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(45, 45, 45, 0.7);
            border-radius: 4px;
            padding: 4px 8px;
            color: #888;
            font-size: 10px;
            font-family: monospace;
            pointer-events: none;
        }

        /* Range Slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #4a4a4a;
            border-radius: 4px;
            outline: none;
            padding: 8px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 32px;
            height: 32px;
            background: #f97316;
            border: 7px solid transparent;
            border-radius: 50%;
            background-clip: padding-box;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.1);
            box-shadow: 0 0 0 8px rgba(249, 115, 22, 0.15);
        }

        input[type="range"]::-moz-range-thumb {
            width: 32px;
            height: 32px;
            background: #f97316;
            border: 7px solid transparent;
            border-radius: 50%;
            background-clip: padding-box;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        input[type="range"]::-moz-range-thumb:active {
            transform: scale(1.1);
            box-shadow: 0 0 0 8px rgba(249, 115, 22, 0.15);
        }

        /* Landscape Layout */
        @media (min-width: 768px) and (orientation: landscape) {
            .main-content {
                flex-direction: row;
            }

            .left-panel {
                flex: 1;
                overflow-y: auto;
            }

            .right-panel {
                flex: 2;
                display: flex;
                flex-direction: column;
                gap: 15px;
            }

            .map-section {
                flex: 1;
                height: auto;
            }
        }

        /* Login Screen */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .login-overlay.hidden {
            display: none;
        }

        .login-box {
            background: #2d2d2d;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            max-width: 400px;
            width: 90%;
        }

        .login-box h2 {
            color: #f97316;
            font-size: 28px;
            margin-bottom: 10px;
            text-align: center;
        }

        .login-box p {
            color: #999;
            font-size: 14px;
            text-align: center;
            margin-bottom: 30px;
        }

        .login-input {
            width: 100%;
            padding: 15px;
            background: #3a3a3a;
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            color: #e5e5e5;
            font-size: 16px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }

        .login-input:focus {
            outline: none;
            border-color: #f97316;
        }

        .login-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .login-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(249, 115, 22, 0.4);
        }

        .login-button:active {
            transform: translateY(0);
        }

        .login-error {
            color: #ef4444;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
            display: none;
        }

        .login-error.show {
            display: block;
        }

        /* GPS Marker - instant transform updates */
        /* Apply to SVG, not marker container (MapLibre uses container for positioning) */
        /* No CSS transition - zoom event fires frequently enough for smooth updates */
        .user-marker svg {
            transition: none;
            transform-origin: center center;
            will-change: transform;
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div class="login-overlay" id="login-overlay">
        <div class="login-box">
            <h2>üîí Access Required</h2>
            <p>Enter password to view telemetry</p>
            <form id="login-form" onsubmit="return false;">
                <input
                    type="password"
                    class="login-input"
                    id="password-input"
                    placeholder="Enter password"
                    autocomplete="off"
                    autofocus
                >
                <button type="submit" class="login-button" id="login-button">Unlock</button>
                <div class="login-error" id="login-error">Incorrect password</div>
            </form>
        </div>
    </div>

    <div class="container">
        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Panel: Telemetry -->
            <div class="left-panel">
                <!-- GPS Status -->
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; padding: 8px 12px; background: rgba(45, 45, 45, 0.5); border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="status-indicator waiting" id="status-dot"></span>
                        <span id="status-text" style="font-size: 13px;">Initializing GPS...</span>
                    </div>
                    <span id="accuracy-inline" style="font-size: 12px; opacity: 0.8;">--</span>
                </div>

                <!-- Current Road and Compass Row -->
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 12px; margin-bottom: 12px;">
                    <!-- Current Road/Highway -->
                    <div class="telemetry-card">
                        <div class="telemetry-label">Current Road</div>
                        <div class="telemetry-value" style="font-size: 20px;" id="road-name">Detecting...</div>
                        <div class="telemetry-secondary" id="road-type">--</div>
                    </div>

                    <!-- Compass -->
                    <div class="telemetry-card" style="display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 8px;">
                        <div class="telemetry-label" style="margin-bottom: 8px;">Compass</div>
                        <div class="compass-container">
                            <div class="compass-circle" id="compass-circle">
                                <div class="compass-arrow" id="compass-arrow"></div>
                                <div class="compass-cardinal n">N</div>
                                <div class="compass-cardinal e">E</div>
                                <div class="compass-cardinal s">S</div>
                                <div class="compass-cardinal w">W</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Speed, Heading, Altitude Row -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 12px;">
                    <!-- Speed -->
                    <div class="telemetry-card">
                        <div class="telemetry-label">Speed</div>
                        <div class="telemetry-value large">
                            <span id="speed">--</span>
                            <span class="telemetry-unit">mph</span>
                        </div>
                        <div class="telemetry-secondary" id="speed-limit">--</div>
                    </div>

                    <!-- Heading -->
                    <div class="telemetry-card">
                        <div class="telemetry-label">Heading</div>
                        <div class="telemetry-value">
                            <span id="heading">--</span>
                            <span class="telemetry-unit">¬∞</span>
                            <span class="heading-arrow" id="heading-arrow">
                                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 2L12 22M12 2L6 8M12 2L18 8" stroke="#f97316" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                                    <circle cx="12" cy="12" r="1.5" fill="#f97316"/>
                                </svg>
                            </span>
                        </div>
                        <div class="telemetry-secondary" id="direction">--</div>
                    </div>

                    <!-- Altitude -->
                    <div class="telemetry-card">
                        <div class="telemetry-label">Altitude</div>
                        <div class="telemetry-value">
                            <span id="altitude">--</span>
                            <span class="telemetry-unit">ft</span>
                        </div>
                    </div>
                </div>

                <!-- Upcoming Exits -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header" style="cursor: pointer; user-select: none;" onclick="toggleExits()">
                        Nearby Exits (0.5 mi ahead)
                        <span id="exits-toggle" style="float: right;">‚ñ≤</span>
                    </div>
                    <div id="exits-content" style="display: block;">
                        <div id="exits-list">
                            <div class="no-data">No exits nearby</div>
                        </div>
                    </div>
                </div>

                <!-- Weather Section -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Current Weather</div>
                    <div class="telemetry-grid" style="margin-top: 12px;">
                        <!-- Temperature -->
                        <div class="telemetry-card">
                            <div class="telemetry-label">Temperature</div>
                            <div class="telemetry-value">
                                <span id="weather-temp">--</span>
                                <span class="telemetry-unit">¬∞F</span>
                            </div>
                        </div>

                        <!-- Feels Like -->
                        <div class="telemetry-card">
                            <div class="telemetry-label">Feels Like</div>
                            <div class="telemetry-value">
                                <span id="weather-feels">--</span>
                                <span class="telemetry-unit">¬∞F</span>
                            </div>
                        </div>

                        <!-- Humidity -->
                        <div class="telemetry-card">
                            <div class="telemetry-label">Humidity</div>
                            <div class="telemetry-value">
                                <span id="weather-humidity">--</span>
                                <span class="telemetry-unit">%</span>
                            </div>
                        </div>

                        <!-- Wind -->
                        <div class="telemetry-card">
                            <div class="telemetry-label">Wind</div>
                            <div class="telemetry-value" style="font-size: 20px;">
                                <span id="weather-wind">--</span>
                                <span class="telemetry-unit">mph</span>
                                <span class="wind-arrow" id="wind-arrow">
                                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 2L12 22M12 2L6 8M12 2L18 8" stroke="#f97316" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                                        <circle cx="12" cy="12" r="1.5" fill="#f97316"/>
                                    </svg>
                                </span>
                            </div>
                            <div class="telemetry-secondary">
                                <span id="weather-wind-gust">--</span> ‚Ä¢ <span id="weather-wind-dir">--</span>
                            </div>
                        </div>

                        <!-- Condition -->
                        <div class="telemetry-card full-width">
                            <div class="telemetry-label">Condition</div>
                            <div class="telemetry-value" style="font-size: 20px;" id="weather-condition">Loading...</div>
                        </div>

                        <!-- Sunrise/Sunset -->
                        <div class="telemetry-card full-width">
                            <div class="telemetry-label" id="sun-label">--</div>
                            <div class="telemetry-value" style="font-size: 20px;" id="sun-time">--</div>
                        </div>
                    </div>
                </div>

                <!-- Radar Opacity Control -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Radar Opacity</div>
                    <div style="padding: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button id="opacity-decrease" style="width: 32px; height: 32px; border: none; background: #2a2a2a; color: #f97316; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">‚àí</button>
                            <input type="range" id="radar-opacity-slider" min="0" max="100" value="60" style="flex: 1;">
                            <button id="opacity-increase" style="width: 32px; height: 32px; border: none; background: #2a2a2a; color: #f97316; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">+</button>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 11px; color: #666;">
                            <span>0%</span>
                            <span id="radar-opacity-value">60%</span>
                            <span>100%</span>
                        </div>
                    </div>
                </div>

                <!-- Map Zoom Control -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Map Zoom</div>
                    <div style="padding: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button id="zoom-decrease" style="width: 32px; height: 32px; border: none; background: #2a2a2a; color: #f97316; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">‚àí</button>
                            <input type="range" id="map-zoom-slider" min="8" max="19" value="17" style="flex: 1;">
                            <button id="zoom-increase" style="width: 32px; height: 32px; border: none; background: #2a2a2a; color: #f97316; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">+</button>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 11px; color: #666;">
                            <span>8</span>
                            <span id="map-zoom-value">17</span>
                            <span>19</span>
                        </div>
                    </div>
                </div>

                <!-- Map Style Selector -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Map Style</div>
                    <div style="padding: 12px;">
                        <select id="map-style-selector" style="width: 100%; padding: 8px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #444; border-radius: 4px; cursor: pointer; font-size: 13px;">
                            <option value="satellite">Satellite</option>
                            <option value="executive-light">Executive Lightmode</option>
                            <option value="executive-dark">Executive Darkmode</option>
                            <option value="cartoon-light">Cartoon Lightmode</option>
                            <option value="cartoon-dark">Cartoon Darkmode</option>
                            <option value="holiday-light">Holiday Lightmode</option>
                            <option value="holiday-dark">Holiday Darkmode</option>
                        </select>
                    </div>
                </div>

                <!-- Vehicle Type Selector -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Vehicle Type</div>
                    <div style="padding: 12px;">
                        <select id="vehicle-type-selector" style="width: 100%; padding: 8px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #444; border-radius: 4px; cursor: pointer; font-size: 13px;">
                            <option value="car">üöó Car (No height restrictions)</option>
                            <option value="suv">üöô SUV/Van (No restrictions)</option>
                            <option value="rv">üöê RV/Camper (11' / 3.35m clearance)</option>
                            <option value="truck">üöö Truck/Box Truck (13'6" / 4.11m clearance)</option>
                        </select>
                    </div>
                </div>

                <!-- 3D Perspective View Controls -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">View Mode</div>
                    <div style="padding: 12px;">
                        <!-- Perspective Toggle Button -->
                        <button id="perspective-toggle" style="width: 100%; padding: 12px; background: #3a3a3a; color: #999; border: 2px solid #444; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold; margin-bottom: 10px; transition: all 0.3s ease;">
                            üó∫Ô∏è 2D Map View (North Up)
                        </button>

                        <!-- Auto-Rotation Checkbox -->
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: #2a2a2a; border-radius: 4px;">
                            <input type="checkbox" id="auto-rotation-checkbox" style="width: 18px; height: 18px; cursor: pointer; accent-color: #f97316;" disabled>
                            <label for="auto-rotation-checkbox" style="font-size: 12px; color: #999; cursor: pointer; user-select: none;">
                                Auto-rotate when driving (>5 MPH)
                            </label>
                        </div>
                        <div style="font-size: 10px; color: #666; margin-top: 6px; padding-left: 4px;">
                            üí° Enable 3D view first to use auto-rotation
                        </div>
                    </div>
                </div>

                <!-- Style Customization Editor -->
                <div id="style-customization-section" class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header" style="cursor: pointer; user-select: none;" onclick="toggleStyleEditor()">
                        üé® Customize Colors
                        <span id="style-editor-toggle" style="float: right;">‚ñ≤</span>
                    </div>
                    <div id="style-editor-content" style="display: block; padding: 12px;">
                        <!-- Roads -->
                        <div style="margin-bottom: 12px;">
                            <div style="color: #f97316; font-size: 12px; font-weight: bold; margin-bottom: 6px;">Roads</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Highways:</label>
                                <input type="color" id="color-highway" value="#FFA500" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Major Roads:</label>
                                <input type="color" id="color-primary" value="#FFDD88" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Streets:</label>
                                <input type="color" id="color-street" value="#FFFFFF" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                        </div>

                        <!-- Buildings -->
                        <div style="margin-bottom: 12px;">
                            <div style="color: #f97316; font-size: 12px; font-weight: bold; margin-bottom: 6px;">Buildings</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Fill Color:</label>
                                <input type="color" id="color-building" value="#E4DCD0" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                        </div>

                        <!-- Water -->
                        <div style="margin-bottom: 12px;">
                            <div style="color: #f97316; font-size: 12px; font-weight: bold; margin-bottom: 6px;">Water</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Water Bodies:</label>
                                <input type="color" id="color-water" value="#B0D0D6" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Rivers:</label>
                                <input type="color" id="color-waterway" value="#CCE7EA" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <label style="font-size: 11px; color: #ccc;">Parks:</label>
                                <input type="color" id="color-park" value="#C8E6C9" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                        </div>

                        <!-- Map & Text -->
                        <div style="margin-bottom: 12px;">
                            <div style="color: #f97316; font-size: 12px; font-weight: bold; margin-bottom: 6px;">Map & Text</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Background:</label>
                                <input type="color" id="color-background" value="#F5F5F0" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Text Labels:</label>
                                <input type="color" id="color-text" value="#333333" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <label style="font-size: 11px; color: #ccc;">Text Size:</label>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="range" id="text-size-slider" min="8" max="26" value="18" style="width: 80px;">
                                    <span id="text-size-value" style="font-size: 11px; color: #f97316; min-width: 30px;">18px</span>
                                </div>
                            </div>
                        </div>

                        <!-- Vehicle Marker -->
                        <div style="margin-bottom: 12px;">
                            <div style="color: #f97316; font-size: 12px; font-weight: bold; margin-bottom: 6px;">Vehicle Marker</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Marker Color:</label>
                                <input type="color" id="color-marker" value="#4285F4" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <label style="font-size: 11px; color: #ccc;">Border Color:</label>
                                <input type="color" id="color-marker-border" value="#FFFFFF" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                        </div>

                        <!-- Actions -->
                        <div style="display: flex; gap: 6px; margin-top: 15px;">
                            <button onclick="applyCustomStyle()" style="flex: 1; padding: 8px; background: #f97316; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">Apply</button>
                            <button onclick="saveCustomStyle()" style="padding: 8px 12px; background: #2a2a2a; color: #f97316; border: 1px solid #f97316; border-radius: 4px; cursor: pointer; font-size: 12px;">Save</button>
                            <button onclick="resetStyle()" style="padding: 8px 12px; background: #2a2a2a; color: #ccc; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Map -->
            <div class="right-panel">
                <div class="map-section">
                    <input
                        type="text"
                        class="search-box"
                        id="search-box"
                        placeholder="Navigation Coming Soon"
                        disabled
                    >
                    <div class="map-coordinates" id="map-coordinates">--</div>
                    <div id="map"></div>
                    <div id="rain-overlay" class="rain-overlay"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

    <script>
        // ==================== PASSWORD PROTECTION ====================
        const CORRECT_PASSWORD = 'TripX9k2'; // Random access password

        // Handle login
        document.addEventListener('DOMContentLoaded', () => {
            const loginForm = document.getElementById('login-form');
            const passwordInput = document.getElementById('password-input');
            const loginButton = document.getElementById('login-button');
            const loginError = document.getElementById('login-error');
            const loginOverlay = document.getElementById('login-overlay');

            // Check if password is in URL (e.g., ?password=TripX9k2)
            const urlParams = new URLSearchParams(window.location.search);
            const urlPassword = urlParams.get('password');

            if (urlPassword === CORRECT_PASSWORD) {
                // Password in URL is correct - skip login screen
                loginOverlay.classList.add('hidden');
                initApp();
                return;
            }

            // Set up manual login form
            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const enteredPassword = passwordInput.value;

                if (enteredPassword === CORRECT_PASSWORD) {
                    // Correct password - hide login and start app
                    loginOverlay.classList.add('hidden');
                    initApp();
                } else {
                    // Wrong password - show error
                    loginError.classList.add('show');
                    passwordInput.value = '';
                    passwordInput.focus();

                    // Hide error after 2 seconds
                    setTimeout(() => {
                        loginError.classList.remove('show');
                    }, 2000);
                }
            });

            loginButton.addEventListener('click', () => {
                loginForm.dispatchEvent(new Event('submit'));
            });
        });

        // ==================== STATE ====================
        let map = null;
        let userMarker = null;
        let exitMarkers = [];
        let decorativeTreeMarkers = new Map(); // Store tree markers by tree key for persistence
        let lastTreeUpdateLocation = null; // Track last GPS location where trees were updated

        let nearbyOverpasses = []; // Store detected overpasses
        let lastOverpassCheck = null; // Last GPS position where we checked
        let activeOverpassAlert = null; // Currently displayed alert

        // Radar State
        let radarLayerVisible = false; // Track if radar layer is currently visible

        // 3D Perspective View State
        let perspectiveMode = false; // Current view mode (false = 2D, true = 3D)
        let autoRotationEnabled = false; // Auto-rotation when driving
        let lastBearing = null; // Last heading to prevent unnecessary updates
        let perspectiveDisabledByZoom = false; // Track if perspective was auto-disabled due to zoom level
        let savedAutoRotationState = false; // Save auto-rotation state when auto-disabling perspective
        let perspectiveToggleInProgress = false; // Prevent GPS updates from interfering during toggle animation

        // House Number State Management
        let houseNumbersEnabled = false; // Whether house numbers are currently visible
        let buildingCache = {
            tiles: {},          // Cache building data by tile key
            maxTiles: 50,       // Maximum number of tiles to cache
            tileQueue: []       // LRU queue for cache eviction
        };
        let overpassQueue = {
            queue: [],              // Queue of pending requests
            processing: false,      // Whether a request is currently being processed
            lastRequestTime: 0,     // Timestamp of last request
            minInterval: 1000       // Minimum milliseconds between requests
        };
        let lastViewportUpdateTime = 0; // For debouncing viewport updates
        const VIEWPORT_UPDATE_DEBOUNCE = 500; // ms

        let currentLocation = null;
        let previousLocation = null;
        let roadInfo = null;
        let nearbyExits = [];
        let weatherData = null;
        let markerAnimation = null; // Track ongoing marker animation
        let lastGPSUpdateTime = null; // Track when GPS updates arrive
        let gpsUpdateIntervals = []; // Rolling average of update intervals
        let currentVelocity = { lat: 0, lng: 0 }; // Velocity in degrees/ms
        let isExtrapolating = false; // Whether we're extrapolating beyond GPS data

        // GPS Smoothing State
        let smoothedLocation = null; // EWMA-smoothed GPS position
        const SMOOTHING_FACTOR = 0.3; // Default smoothing factor (0=max smooth, 1=no smooth)
        let stationaryStartTime = null; // Track stationary duration

        // Speed limit caching
        let speedLimitCache = {
            value: null,        // Cached speed limit in mph
            road: null,         // Road name when cached (e.g., "I25")
            direction: null,    // Direction of travel (N, S, E, W, NE, etc.)
            isCached: false     // Whether current display is from cache
        };

        // Road geometry caching for map-matching and road-following
        let roadGeometryCache = {
            segments: [],           // Array of road segments with geometry
            currentSegment: null,   // Active segment marker is on
            currentPosition: null,  // Current position on road {segmentIndex, progress, lat, lng}
            lastFetch: 0,          // Timestamp of last geometry fetch
            lastFetchLat: null,    // Last fetch location
            lastFetchLng: null
        };

        const UPDATE_INTERVAL = 1000; // Update display every second
        const ROAD_QUERY_INTERVAL = 5000; // Query road info every 5 seconds
        const EXIT_QUERY_INTERVAL = 10000; // Query exits every 10 seconds
        const WEATHER_QUERY_INTERVAL = 300000; // Query weather every 5 minutes
        const SPEED_LIMIT_QUERY_INTERVAL = 10000; // Query speed limit every 10 seconds

        let lastRoadQuery = 0;
        let lastExitQuery = 0;
        let lastWeatherQuery = 0;
        let lastSpeedLimitQuery = 0;

        // ==================== REMOTE LOGGING CONFIG ====================
        const REMOTE_LOGGING_CONFIG = {
            enabled: true,
            webhookUrl: 'https://script.google.com/macros/s/AKfycbxbK-E1FflgbZnKWjmUtcEOebVbgIUKgmGd-asZ0Tk6c5HwKryJV-o3h4SEBqqiJfbX/exec',
            secret: 'ABCD1234',
            debugMode: false,  // Set true to log console.log() calls
            batchInterval: 30000,  // Batch every 30 seconds
            batchSize: 10,  // Or when 10 logs accumulated
            timeout: 5000,
            maxQueueSize: 100,
            immediateLogLevels: ['error', 'warn']  // Send these immediately
        };

        let loggingQueue = [];
        let sessionId = `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        let batchTimer = null;
        let pendingLogsInLocalStorage = [];

        // ==================== INIT ====================
        function initApp() {
            initRemoteLogging();  // Initialize remote logging FIRST
            initMap();
            initGPS();
            loadRadar();
            setInterval(updateDisplay, UPDATE_INTERVAL);
            initRadarOpacitySlider();
            initMapZoomSlider();
            initMapStyleSelector();
            initVehicleTypeSelector();
            initPerspectiveControls();
            initTextSizeSlider();
            loadSavedColors();
            restoreExitsState();
        }

        function restoreExitsState() {
            const collapsed = localStorage.getItem('exits-collapsed');
            if (collapsed === 'true') {
                const content = document.getElementById('exits-content');
                const toggle = document.getElementById('exits-toggle');
                content.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }

        // ==================== REMOTE LOGGING FUNCTIONS ====================

        function initRemoteLogging() {
            if (!REMOTE_LOGGING_CONFIG.enabled) return;

            loadPendingLogs();
            startBatchTimer();

            // Override console methods
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;

            console.log = function(...args) {
                originalLog.apply(console, args);
                if (REMOTE_LOGGING_CONFIG.debugMode) {
                    captureLog('log', args);
                }
            };

            console.error = function(...args) {
                originalError.apply(console, args);
                captureLog('error', args);
            };

            console.warn = function(...args) {
                originalWarn.apply(console, args);
                captureLog('warn', args);
            };

            // Capture unhandled errors
            window.addEventListener('error', (event) => {
                captureLog('error', ['Unhandled error:', event.message, 'at', event.filename, event.lineno]);
            });

            window.addEventListener('unhandledrejection', (event) => {
                captureLog('error', ['Unhandled promise rejection:', event.reason]);
            });
        }

        function captureLog(level, args) {
            const message = args.map(arg => {
                if (typeof arg === 'object') {
                    try { return JSON.stringify(arg); }
                    catch (e) { return String(arg); }
                }
                return String(arg);
            }).join(' ');

            const logEntry = {
                timestamp: new Date().toISOString(),
                level: level.toUpperCase(),
                message: message.substring(0, 500),
                details: '',
                location: currentLocation ? `${currentLocation.lat.toFixed(6)},${currentLocation.lng.toFixed(6)}` : '',
                road: roadInfo?.road || '',
                city: roadInfo?.city || '',
                speed: currentLocation?.speed ? (currentLocation.speed * 2.237).toFixed(0) : '',
                sessionId: sessionId,
                userAgent: navigator.userAgent
            };

            loggingQueue.push(logEntry);

            if (loggingQueue.length > REMOTE_LOGGING_CONFIG.maxQueueSize) {
                loggingQueue.shift();
            }

            if (REMOTE_LOGGING_CONFIG.immediateLogLevels.includes(level)) {
                sendLogsImmediately([logEntry]);
            } else if (loggingQueue.length >= REMOTE_LOGGING_CONFIG.batchSize) {
                sendBatchedLogs();
            }
        }

        async function sendLogsInChunks(logs, chunkSize) {
            // Split logs into smaller chunks to avoid URL length limits
            const chunks = [];
            for (let i = 0; i < logs.length; i += chunkSize) {
                chunks.push(logs.slice(i, i + chunkSize));
            }

            let allSuccessful = true;

            for (const chunk of chunks) {
                try {
                    const url = new URL(REMOTE_LOGGING_CONFIG.webhookUrl);
                    url.searchParams.set('secret', REMOTE_LOGGING_CONFIG.secret);
                    url.searchParams.set('data', encodeURIComponent(JSON.stringify(chunk)));

                    // Check URL length (max 2000 chars for safety)
                    if (url.toString().length > 2000) {
                        // If still too long, split into even smaller chunks
                        if (chunk.length > 1) {
                            await sendLogsInChunks(chunk, Math.floor(chunk.length / 2));
                            continue;
                        } else {
                            // Single log is too long - truncate message
                            chunk[0].message = chunk[0].message.substring(0, 100);
                        }
                    }

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), REMOTE_LOGGING_CONFIG.timeout);

                    const response = await fetch(url.toString(), {
                        method: 'GET',
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        savePendingLogs(chunk);
                        allSuccessful = false;
                    }

                    // Small delay between chunks to avoid rate limiting
                    if (chunks.length > 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                } catch (error) {
                    savePendingLogs(chunk);
                    allSuccessful = false;
                }
            }

            return allSuccessful;
        }

        async function sendLogsImmediately(logs) {
            // Send in small batches to avoid URL length limits
            await sendLogsInChunks(logs, 3);
        }

        async function sendBatchedLogs() {
            if (loggingQueue.length === 0) return;

            const logsToSend = [...pendingLogsInLocalStorage, ...loggingQueue];
            loggingQueue = [];

            // Send in small batches to avoid URL length limits
            const success = await sendLogsInChunks(logsToSend, 5);

            if (success) {
                pendingLogsInLocalStorage = [];
                localStorage.removeItem('pending_logs');
            }
        }

        function startBatchTimer() {
            batchTimer = setInterval(() => {
                sendBatchedLogs();
            }, REMOTE_LOGGING_CONFIG.batchInterval);
        }

        function savePendingLogs(logs) {
            try {
                pendingLogsInLocalStorage.push(...logs);
                if (pendingLogsInLocalStorage.length > 100) {
                    pendingLogsInLocalStorage = pendingLogsInLocalStorage.slice(-100);
                }
                localStorage.setItem('pending_logs', JSON.stringify(pendingLogsInLocalStorage));
            } catch (e) {
                // localStorage full - silently fail
            }
        }

        function loadPendingLogs() {
            try {
                const stored = localStorage.getItem('pending_logs');
                if (stored) {
                    pendingLogsInLocalStorage = JSON.parse(stored);
                }
            } catch (e) {
                pendingLogsInLocalStorage = [];
            }
        }

        function initRadarOpacitySlider() {
            const slider = document.getElementById('radar-opacity-slider');
            const valueDisplay = document.getElementById('radar-opacity-value');
            const decreaseBtn = document.getElementById('opacity-decrease');
            const increaseBtn = document.getElementById('opacity-increase');

            // Slider input handler
            slider.addEventListener('input', (e) => {
                const opacity = e.target.value / 100;
                valueDisplay.textContent = `${e.target.value}%`;

                // Update radar layer opacity if it exists
                if (map.getLayer('radar-layer')) {
                    map.setPaintProperty('radar-layer', 'raster-opacity', opacity);
                }
            });

            // Decrease button (-5)
            decreaseBtn.addEventListener('click', () => {
                const currentValue = parseInt(slider.value);
                const newValue = Math.max(0, currentValue - 5);
                slider.value = newValue;
                valueDisplay.textContent = `${newValue}%`;

                if (map.getLayer('radar-layer')) {
                    map.setPaintProperty('radar-layer', 'raster-opacity', newValue / 100);
                }
            });

            // Increase button (+5)
            increaseBtn.addEventListener('click', () => {
                const currentValue = parseInt(slider.value);
                const newValue = Math.min(100, currentValue + 5);
                slider.value = newValue;
                valueDisplay.textContent = `${newValue}%`;

                if (map.getLayer('radar-layer')) {
                    map.setPaintProperty('radar-layer', 'raster-opacity', newValue / 100);
                }
            });
        }

        function initMapZoomSlider() {
            const slider = document.getElementById('map-zoom-slider');
            const valueDisplay = document.getElementById('map-zoom-value');
            const decreaseBtn = document.getElementById('zoom-decrease');
            const increaseBtn = document.getElementById('zoom-increase');

            // Slider input handler
            slider.addEventListener('input', (e) => {
                const zoom = parseInt(e.target.value);
                valueDisplay.textContent = zoom;

                if (map) {
                    map.setZoom(zoom);
                }
            });

            // Decrease button (-1)
            decreaseBtn.addEventListener('click', () => {
                const currentValue = parseInt(slider.value);
                const newValue = Math.max(8, currentValue - 1);
                slider.value = newValue;
                valueDisplay.textContent = newValue;

                if (map) {
                    map.easeTo({
                        zoom: newValue,
                        duration: 1000
                    });
                }
            });

            // Increase button (+1)
            increaseBtn.addEventListener('click', () => {
                const currentValue = parseInt(slider.value);
                const newValue = Math.min(19, currentValue + 1);
                slider.value = newValue;
                valueDisplay.textContent = newValue;

                if (map) {
                    map.easeTo({
                        zoom: newValue,
                        duration: 1000
                    });
                }
            });

            // Update slider when map zoom changes (e.g., pinch zoom, scroll wheel)
            if (map) {
                map.on('zoomend', () => {
                    const currentZoom = map.getZoom();
                    slider.value = currentZoom;
                    valueDisplay.textContent = currentZoom;
                });
            }
        }

        // Get predefined theme colors
        function getThemeColors(themeName) {
            const themes = {
                'executive-light': {
                    highway: '#5A5A5A',
                    primary: '#8B8B8B',
                    street: '#CCCCCC',
                    building: '#E8E3D8',
                    water: '#7BA7BC',
                    waterway: '#A5C4D4',
                    park: '#A8C5A0',
                    background: '#F5F5F0',
                    text: '#2C2C2C',
                    textSize: 18
                },
                'executive-dark': {
                    highway: '#CCCCCC',
                    primary: '#999999',
                    street: '#666666',
                    building: '#3A3A3A',
                    water: '#2B4C6F',
                    waterway: '#456B8A',
                    park: '#3D5C3D',
                    background: '#1A1A1A',
                    text: '#E0E0E0',
                    textSize: 18
                },
                'cartoon-light': {
                    highway: '#FF4444',
                    primary: '#FFA500',
                    street: '#FFD700',
                    building: '#9B59B6',
                    water: '#00CED1',
                    waterway: '#87CEEB',
                    park: '#7FFF00',
                    background: '#FFF8DC',
                    text: '#4A235A',
                    textSize: 18
                },
                'cartoon-dark': {
                    highway: '#FF69B4',
                    primary: '#FF6B6B',
                    street: '#FFD93D',
                    building: '#B565D8',
                    water: '#00BFFF',
                    waterway: '#00FFFF',
                    park: '#39FF14',
                    background: '#1C1C3C',
                    text: '#FFFFFF',
                    textSize: 18
                },
                'holiday-light': {
                    highway: '#C41E3A',
                    primary: '#8B0000',
                    street: '#FFFFFF',
                    building: '#F5E6D3',
                    water: '#B0C4DE',
                    waterway: '#D4E4F7',
                    park: '#0F8B3D',
                    background: '#FFFAFA',
                    text: '#1B4D3E',
                    textSize: 18
                },
                'holiday-dark': {
                    highway: '#FF0000',
                    primary: '#DA291C',
                    street: '#98FF98',
                    building: '#3E2723',
                    water: '#1E4D8B',
                    waterway: '#4A90E2',
                    park: '#2D5016',
                    background: '#0D1B0E',
                    text: '#FFD700',
                    textSize: 18
                }
            };
            return themes[themeName] || null;
        }

        // Toggle customization section visibility based on style
        function updateCustomizationAvailability(styleName) {
            const customizationSection = document.getElementById('style-customization-section');

            if (styleName === 'satellite') {
                // Disable customization for satellite view
                customizationSection.style.opacity = '0.5';
                customizationSection.style.pointerEvents = 'none';
                customizationSection.title = 'Color customization not available for Satellite view';
            } else {
                // Enable customization for all other styles
                customizationSection.style.opacity = '1';
                customizationSection.style.pointerEvents = 'auto';
                customizationSection.title = '';
            }
        }

        function initMapStyleSelector() {
            const selector = document.getElementById('map-style-selector');

            // Load saved style preference (default to executive-light if old voyager/dark value)
            let savedStyle = localStorage.getItem('map_style') || 'executive-light';

            // Migrate old voyager/dark values to executive-light
            if (savedStyle === 'voyager' || savedStyle === 'dark') {
                savedStyle = 'executive-light';
                localStorage.setItem('map_style', savedStyle);
            }

            selector.value = savedStyle;

            // Set initial customization availability
            updateCustomizationAvailability(savedStyle);

            // Handle style change
            selector.addEventListener('change', async (e) => {
                const newStyle = e.target.value;

                // Save preference
                localStorage.setItem('map_style', newStyle);

                // Update customization availability
                updateCustomizationAvailability(newStyle);

                // Check if this is a themed style
                const themeColors = getThemeColors(newStyle);

                if (themeColors) {
                    // Apply themed colors
                    const baseStyleURL = getVectorStyleURL(newStyle);
                    const customStyleJSON = await fetchAndCustomizeStyle(baseStyleURL, themeColors);
                    map.setStyle(customStyleJSON);

                    // Update color pickers to match theme
                    document.getElementById('color-highway').value = themeColors.highway;
                    document.getElementById('color-primary').value = themeColors.primary;
                    document.getElementById('color-street').value = themeColors.street;
                    document.getElementById('color-building').value = themeColors.building;
                    document.getElementById('color-water').value = themeColors.water;
                    document.getElementById('color-waterway').value = themeColors.waterway;
                    document.getElementById('color-park').value = themeColors.park;
                    document.getElementById('color-background').value = themeColors.background;
                    document.getElementById('color-text').value = themeColors.text;
                    document.getElementById('text-size-slider').value = themeColors.textSize;
                    document.getElementById('text-size-value').textContent = themeColors.textSize + 'px';
                } else {
                    // Standard map style (satellite)
                    map.setStyle(getVectorStyleURL(newStyle));
                }

                // Re-add radar and trees after style loads
                map.once('styledata', () => {
                    loadRadar();
                    addDecorativeTrees(newStyle); // Add trees for cartoon/holiday themes
                });

                console.log(`Map style changed to: ${newStyle}`);
            });
        }

        function initVehicleTypeSelector() {
            const selector = document.getElementById('vehicle-type-selector');

            // Load saved preference
            const savedVehicleType = localStorage.getItem('vehicle_type') || 'car';
            selector.value = savedVehicleType;

            // Handle change
            selector.addEventListener('change', (e) => {
                const vehicleType = e.target.value;
                localStorage.setItem('vehicle_type', vehicleType);
                console.log(`Vehicle type changed to: ${vehicleType}`);

                // Re-check nearby overpasses with new vehicle type
                if (currentLocation) {
                    checkNearbyOverpasses(currentLocation.lat, currentLocation.lng);
                }
            });
        }

        function initPerspectiveControls() {
            const toggleButton = document.getElementById('perspective-toggle');
            const autoRotationCheckbox = document.getElementById('auto-rotation-checkbox');

            console.log('initPerspectiveControls called');
            console.log('toggleButton:', toggleButton);
            console.log('autoRotationCheckbox:', autoRotationCheckbox);

            if (!toggleButton) {
                console.error('perspective-toggle button not found!');
                return;
            }

            // Load saved preferences (default to enabled)
            const savedPerspectiveMode = localStorage.getItem('perspective_mode') !== 'false';
            const savedAutoRotation = localStorage.getItem('auto_rotation') !== 'false';

            // Set initial state
            perspectiveMode = savedPerspectiveMode;
            autoRotationEnabled = savedAutoRotation;
            autoRotationCheckbox.checked = savedAutoRotation;

            // Update button appearance
            updatePerspectiveButton();

            // Note: We'll apply the saved perspective mode after the map loads
            // The map isn't created yet when this function is called

            // Toggle button click handler
            console.log('Attaching click event listener to perspective toggle button');
            toggleButton.addEventListener('click', () => {
                console.log('BUTTON CLICKED!!!');
                togglePerspectiveMode();
            });

            // Auto-rotation checkbox change handler
            autoRotationCheckbox.addEventListener('change', (e) => {
                autoRotationEnabled = e.target.checked;
                localStorage.setItem('auto_rotation', autoRotationEnabled ? 'true' : 'false');

                console.log(`Auto-rotation ${autoRotationEnabled ? 'enabled' : 'disabled'}`);

                // If enabling auto-rotation and we're in perspective mode, apply current heading
                if (autoRotationEnabled && perspectiveMode && lastBearing !== null) {
                    map.easeTo({
                        bearing: lastBearing,
                        duration: 800
                    });
                }

                // If disabling auto-rotation, reset bearing to north
                if (!autoRotationEnabled) {
                    map.easeTo({
                        bearing: 0,
                        duration: 800
                    });
                }
            });
        }

        function initTextSizeSlider() {
            const slider = document.getElementById('text-size-slider');
            const valueDisplay = document.getElementById('text-size-value');

            // Slider input handler - update display in real-time
            slider.addEventListener('input', (e) => {
                valueDisplay.textContent = `${e.target.value}px`;
            });
        }

        // Get vector style URL for MapLibre GL JS
        function getVectorStyleURL(styleName) {
            const styles = {
                voyager: 'https://tiles.basemaps.cartocdn.com/gl/voyager-gl-style/style.json',
                dark: 'https://tiles.basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
                satellite: 'https://tiles.basemaps.cartocdn.com/gl/positron-gl-style/style.json'
            };

            // Themed styles use voyager as base
            if (styleName.includes('executive') || styleName.includes('cartoon') || styleName.includes('holiday')) {
                return styles.voyager;
            }

            return styles[styleName] || styles.voyager;
        }

        async function initMap() {
            // Load saved style preference (default to executive-light if old voyager/dark value)
            let savedStyle = localStorage.getItem('map_style') || 'executive-light';

            // Migrate old voyager/dark values to executive-light
            if (savedStyle === 'voyager' || savedStyle === 'dark') {
                savedStyle = 'executive-light';
                localStorage.setItem('map_style', savedStyle);
            }

            const themeColors = getThemeColors(savedStyle);

            let initialStyle;
            if (themeColors) {
                // Apply themed style on load
                const baseStyleURL = getVectorStyleURL(savedStyle);
                initialStyle = await fetchAndCustomizeStyle(baseStyleURL, themeColors);
            } else {
                initialStyle = getVectorStyleURL(savedStyle);
            }

            map = new maplibregl.Map({
                container: 'map',
                style: initialStyle,
                center: [-122.4194, 37.7749], // [lng, lat] - REVERSED from Leaflet!
                zoom: 17,
                attributionControl: false
            });

            map.on('load', () => {
                console.log('Map loaded successfully');
                loadRadar(); // Add radar after style loads
                startRadarRefresh(); // Start periodic radar refresh
                startRadarRainCheck(); // Start periodic rain detection
                addDecorativeTrees(savedStyle); // Add trees if cartoon/holiday theme

                // Initialize house number layer
                initializeHouseNumberLayer();

                // Apply saved perspective mode if it was enabled and zoom allows it
                if (perspectiveMode) {
                    const currentZoom = map.getZoom();
                    if (currentZoom >= 16) {
                        map.setPitch(45);
                        console.log('Restored 3D perspective mode from localStorage');
                    } else {
                        // Zoom too low - disable perspective but remember user preference
                        perspectiveMode = false;
                        perspectiveDisabledByZoom = true;
                        updatePerspectiveButton();
                        console.log('Perspective mode saved in localStorage, but zoom < 16 - will re-enable when zoomed in');
                    }
                }

                // Set initial customization availability
                updateCustomizationAvailability(savedStyle);

                // If theme was applied, update color pickers
                if (themeColors) {
                    document.getElementById('color-highway').value = themeColors.highway;
                    document.getElementById('color-primary').value = themeColors.primary;
                    document.getElementById('color-street').value = themeColors.street;
                    document.getElementById('color-building').value = themeColors.building;
                    document.getElementById('color-water').value = themeColors.water;
                    document.getElementById('color-waterway').value = themeColors.waterway;
                    document.getElementById('color-park').value = themeColors.park;
                    document.getElementById('color-background').value = themeColors.background;
                    document.getElementById('color-text').value = themeColors.text;
                    document.getElementById('text-size-slider').value = themeColors.textSize;
                    document.getElementById('text-size-value').textContent = themeColors.textSize + 'px';
                }
            });

            // Update marker during zoom for smooth scaling and type swapping
            map.on('zoom', () => {
                checkAndSwapMarkerType(); // Swap between car and dot at zoom 16
                updateMarkerScale();

                // Update trees in real-time during zoom
                const savedStyle = localStorage.getItem('map_style') || 'voyager';
                updateDecorativeTrees(savedStyle);
            });

            // Update zoom slider when map zooms
            map.on('zoomend', () => {
                const zoom = Math.round(map.getZoom());
                const slider = document.getElementById('map-zoom-slider');
                const valueDisplay = document.getElementById('map-zoom-value');
                if (slider) slider.value = zoom;
                if (valueDisplay) valueDisplay.textContent = zoom;

                // Check if we need to disable/enable perspective mode based on zoom
                const currentZoom = map.getZoom();

                if (currentZoom < 16) {
                    // Zoomed out too far - disable perspective if it's on
                    if (perspectiveMode && !perspectiveDisabledByZoom) {
                        // Save current auto-rotation state before disabling
                        savedAutoRotationState = autoRotationEnabled;
                        perspectiveDisabledByZoom = true;
                        perspectiveToggleInProgress = true;
                        console.log('Auto-disabling 3D perspective due to zoom level < 16');

                        // Manually disable perspective without calling disablePerspectiveMode
                        // to preserve auto-rotation state in memory
                        perspectiveMode = false;

                        if (currentLocation) {
                            map.easeTo({
                                pitch: 0,
                                bearing: 0,
                                center: [currentLocation.lng, currentLocation.lat],
                                offset: [0, 0],
                                duration: 800
                            });
                        } else {
                            map.easeTo({
                                pitch: 0,
                                bearing: 0,
                                duration: 800
                            });
                        }

                        // Update UI but don't modify auto-rotation state
                        updatePerspectiveButton();
                        localStorage.setItem('perspective_mode', 'false');

                        // Clear toggle flag after animation completes
                        setTimeout(() => {
                            perspectiveToggleInProgress = false;
                        }, 800);
                    }
                } else {
                    // Zoomed in enough - re-enable perspective if it was auto-disabled
                    if (perspectiveDisabledByZoom) {
                        console.log(`Auto-re-enable triggered - savedAutoRotationState: ${savedAutoRotationState}`);
                        perspectiveDisabledByZoom = false;
                        perspectiveToggleInProgress = true;

                        // Restore saved auto-rotation state
                        autoRotationEnabled = savedAutoRotationState;

                        console.log(`Re-enabling 3D perspective at zoom level >= 16 (auto-rotation: ${autoRotationEnabled})`);

                        // Manually re-enable perspective mode
                        perspectiveMode = true;
                        console.log(`perspectiveMode set to: ${perspectiveMode}`);

                        // Calculate center and offset for 3D mode
                        const container = map.getContainer();
                        const containerHeight = container.offsetHeight;
                        const yOffset = containerHeight * 0.25;

                        // Determine bearing
                        const bearing = (autoRotationEnabled && lastBearing !== null) ? lastBearing : 0;

                        // Combine all animations into a single easeTo call
                        if (currentLocation) {
                            map.easeTo({
                                pitch: 45,
                                bearing: bearing,
                                center: [currentLocation.lng, currentLocation.lat],
                                offset: [0, yOffset],
                                duration: 800
                            });
                        } else {
                            map.easeTo({
                                pitch: 45,
                                bearing: bearing,
                                duration: 800
                            });
                        }

                        // Update localStorage and UI
                        localStorage.setItem('perspective_mode', 'true');
                        const autoRotationCheckbox = document.getElementById('auto-rotation-checkbox');
                        if (autoRotationCheckbox) {
                            autoRotationCheckbox.checked = autoRotationEnabled;
                        }
                        updatePerspectiveButton();

                        // Clear toggle flag after animation completes
                        setTimeout(() => {
                            perspectiveToggleInProgress = false;
                        }, 800);
                    }
                }

                // Check house number visibility after zoom changes
                checkHouseNumberVisibility();
            });

            // Update trees when map moves (add/remove trees as viewport changes)
            map.on('moveend', () => {
                const savedStyle = localStorage.getItem('map_style') || 'voyager';
                updateDecorativeTrees(savedStyle);

                // Update house numbers if needed (debounced)
                updateHouseNumbersIfNeeded();
            });
        }

        function initGPS() {
            if (!('geolocation' in navigator)) {
                updateStatus('GPS not supported', 'error');
                console.error('Geolocation API not available');
                return;
            }

            console.log('Initializing GPS with high accuracy mode...');

            const options = {
                enableHighAccuracy: true,
                timeout: 30000,  // Increased to 30 seconds
                maximumAge: 0
            };

            const watchId = navigator.geolocation.watchPosition(
                handleLocationUpdate,
                handleLocationError,
                options
            );

            console.log(`GPS watchPosition started with ID: ${watchId}`);
        }

        // ==================== LOCATION UPDATES ====================
        function handleLocationUpdate(position) {
            const coords = position.coords;
            const now = performance.now();

            // Log GPS update for debugging
            console.log(`GPS Update: lat=${coords.latitude.toFixed(6)}, lng=${coords.longitude.toFixed(6)}, accuracy=${coords.accuracy.toFixed(1)}m, speed=${coords.speed}m/s`);

            // Filter out low-accuracy GPS readings (but allow initial GPS lock)
            const GPS_ACCURACY_THRESHOLD = 50; // meters
            const GPS_INIT_ACCURACY_THRESHOLD = 200; // meters (more lenient for first reading)

            if (currentLocation) {
                // GPS already initialized - apply strict filtering
                if (coords.accuracy > GPS_ACCURACY_THRESHOLD) {
                    console.warn(`GPS accuracy too low (${coords.accuracy}m), ignoring update`);
                    return;
                }
            } else {
                // First GPS reading - be more lenient to allow initialization
                if (coords.accuracy > GPS_INIT_ACCURACY_THRESHOLD) {
                    console.warn(`Initial GPS accuracy too low (${coords.accuracy}m), waiting for better signal`);
                    return;
                }
            }

            // Track GPS update intervals for adaptive animation
            let gpsRecovered = false;
            if (lastGPSUpdateTime) {
                const interval = now - lastGPSUpdateTime;
                gpsUpdateIntervals.push(interval);

                // Keep rolling window of last 5 intervals
                if (gpsUpdateIntervals.length > 5) {
                    gpsUpdateIntervals.shift();
                }

                // Detect GPS signal recovery (gap >5 seconds)
                const GPS_RECOVERY_THRESHOLD = 5000; // ms
                if (interval > GPS_RECOVERY_THRESHOLD) {
                    console.log('GPS signal recovered after loss');
                    smoothedLocation = null; // Reset smoothing for quick position sync
                    gpsRecovered = true;
                }
            }
            lastGPSUpdateTime = now;

            // Save previous location
            if (currentLocation) {
                previousLocation = { ...currentLocation };
            }

            // Calculate speed from position change if not provided by GPS
            let calculatedSpeed = coords.speed; // m/s
            if ((calculatedSpeed === null || calculatedSpeed === undefined) && previousLocation && lastGPSUpdateTime) {
                const timeDelta = (now - lastGPSUpdateTime) / 1000; // seconds
                if (timeDelta > 0) {
                    const distance = calculateDistance(
                        previousLocation.lat,
                        previousLocation.lng,
                        coords.latitude,
                        coords.longitude
                    ); // distance in miles
                    calculatedSpeed = (distance * 1609.34) / timeDelta; // convert miles to meters, then m/s
                }
            }

            // Detect unrealistic position jumps (GPS glitches)
            let isUnreliable = false;
            if (previousLocation && calculatedSpeed !== null) {
                const MAX_REASONABLE_SPEED = 50; // m/s (~112 mph)
                if (calculatedSpeed > MAX_REASONABLE_SPEED) {
                    console.log(`Unrealistic speed (${calculatedSpeed}m/s), flagging as unreliable`);
                    isUnreliable = true;
                }
            }

            // Update current location
            currentLocation = {
                lat: coords.latitude,
                lng: coords.longitude,
                speed: calculatedSpeed, // m/s (from GPS or calculated)
                heading: coords.heading, // degrees
                accuracy: coords.accuracy, // meters
                altitude: coords.altitude, // meters
                altitudeAccuracy: coords.altitudeAccuracy,
                timestamp: position.timestamp,
                isUnreliable: isUnreliable // Flag for GPS glitches
            };

            // Track and preserve heading for GPS signal recovery
            if (currentLocation.heading === null && lastKnownHeading !== null) {
                // Use last known heading if current is unavailable
                currentLocation.heading = lastKnownHeading;
            }

            if (currentLocation.heading !== null) {
                // Update last known heading when we have valid data
                lastKnownHeading = currentLocation.heading;
            }

            // Flag for sync transition if recovering from signal loss
            if (gpsRecovered) {
                currentLocation.requiresSyncTransition = true;
            }

            // Smooth the GPS position
            const smoothed = smoothGPSPosition(
                currentLocation.lat,
                currentLocation.lng,
                currentLocation.accuracy,
                currentLocation.isUnreliable,
                currentLocation.speed || 0
            );

            currentLocation.smoothedLat = smoothed.lat;
            currentLocation.smoothedLng = smoothed.lng;

            // Check for nearby overpasses
            checkNearbyOverpasses(currentLocation.lat, currentLocation.lng);

            // Update 3D perspective rotation if auto-rotation is enabled
            if (currentLocation.speed !== null && currentLocation.heading !== null) {
                checkAutoRotation(currentLocation.speed, currentLocation.heading);
            }

            // Update map marker
            updateMapMarker();

            // Update status
            updateStatus('GPS Active', 'active');

            // Query road info periodically
            const currentTime = Date.now();
            if (currentTime - lastRoadQuery > ROAD_QUERY_INTERVAL) {
                lastRoadQuery = currentTime;
                queryRoadInfo();
            }

            // Query nearby exits periodically
            if (currentTime - lastExitQuery > EXIT_QUERY_INTERVAL) {
                lastExitQuery = currentTime;
                queryNearbyExits();
            }

            // Query weather periodically
            if (currentTime - lastWeatherQuery > WEATHER_QUERY_INTERVAL) {
                lastWeatherQuery = currentTime;
                queryWeather();
            }

            // Query speed limit periodically
            if (currentTime - lastSpeedLimitQuery > SPEED_LIMIT_QUERY_INTERVAL) {
                lastSpeedLimitQuery = currentTime;
                querySpeedLimit();
            }
        }

        function handleLocationError(error) {
            const errorMessages = {
                1: 'Permission denied - Please allow location access',
                2: 'Position unavailable - GPS signal lost',
                3: 'Timeout - GPS took too long to respond'
            };

            const errorMsg = errorMessages[error.code] || 'Unknown GPS error';
            console.error(`GPS Error (code ${error.code}): ${errorMsg}`, error.message);
            updateStatus(`GPS Error: ${errorMsg}`, 'error');
        }

        function getAverageGPSInterval() {
            if (gpsUpdateIntervals.length === 0) return 1000; // Default 1 second
            const sum = gpsUpdateIntervals.reduce((a, b) => a + b, 0);
            return sum / gpsUpdateIntervals.length;
        }

        // Smooth GPS position using Exponential Weighted Moving Average (EWMA)
        function smoothGPSPosition(newLat, newLng, accuracy, isUnreliable, speed) {
            // Adjust smoothing factor based on GPS quality and speed
            let alpha = SMOOTHING_FACTOR;

            // Less smoothing at high speeds for responsiveness
            if (speed > 25) { // >25 m/s (~56 mph)
                alpha = 0.6; // More responsive
            } else if (speed < 5) { // <5 m/s (~11 mph)
                alpha = 0.2; // More smoothing
            } else if (isUnreliable || accuracy > 25) {
                alpha = 0.15; // Heavy smoothing for poor GPS
            } else if (accuracy < 10) {
                alpha = 0.5; // Less smoothing for high-quality GPS
            }

            // Initialize on first reading
            if (!smoothedLocation) {
                smoothedLocation = { lat: newLat, lng: newLng };
                return smoothedLocation;
            }

            // EWMA calculation
            smoothedLocation.lat = smoothedLocation.lat * (1 - alpha) + newLat * alpha;
            smoothedLocation.lng = smoothedLocation.lng * (1 - alpha) + newLng * alpha;

            return smoothedLocation;
        }

        // ==================== MAP MARKER ====================
        // Global variables for marker customization
        let markerFillColor = '#4285F4'; // Default Google Maps blue
        let markerBorderColor = '#FFFFFF'; // Default white border
        let lastKnownHeading = null; // Track last valid heading for GPS recovery

        // Create SVG vehicle icon element
        function createVehicleMarkerElement(fillColor, borderColor) {
            const markerEl = document.createElement('div');
            markerEl.className = 'user-marker';
            markerEl.style.width = '80px';
            markerEl.style.height = '80px';
            markerEl.style.position = 'relative';
            markerEl.style.display = 'flex';
            markerEl.style.alignItems = 'center';
            markerEl.style.justifyContent = 'center';

            // Create SVG element (top-down car view)
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 40 60');
            svg.setAttribute('width', '80');
            svg.setAttribute('height', '80');
            svg.style.filter = 'drop-shadow(0 4px 12px rgba(0,0,0,0.6))';

            // Create gradient for 3D depth effect
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.setAttribute('id', 'carGradient');
            gradient.setAttribute('x1', '0%');
            gradient.setAttribute('y1', '0%');
            gradient.setAttribute('x2', '100%');
            gradient.setAttribute('y2', '0%');

            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('style', `stop-color:${fillColor};stop-opacity:0.8`);

            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '50%');
            stop2.setAttribute('style', `stop-color:${fillColor};stop-opacity:1`);

            const stop3 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop3.setAttribute('offset', '100%');
            stop3.setAttribute('style', `stop-color:${fillColor};stop-opacity:0.8`);

            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            gradient.appendChild(stop3);
            defs.appendChild(gradient);
            svg.appendChild(defs);

            // Main car body (rounded rectangle with tapered front and back)
            const carBody = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            carBody.setAttribute('d', 'M 15 8 L 25 8 L 28 12 L 28 48 L 25 52 L 15 52 L 12 48 L 12 12 Z');
            carBody.setAttribute('fill', 'url(#carGradient)');
            carBody.setAttribute('stroke', borderColor);
            carBody.setAttribute('stroke-width', '2');
            carBody.setAttribute('stroke-linejoin', 'round');

            // Front hood (darker shade for depth)
            const hood = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            hood.setAttribute('d', 'M 15 8 L 25 8 L 27 11 L 27 18 L 13 18 L 13 11 Z');
            hood.setAttribute('fill', fillColor);
            hood.setAttribute('opacity', '0.4');

            // Windshield (lighter for glass effect)
            const windshield = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            windshield.setAttribute('x', '14');
            windshield.setAttribute('y', '19');
            windshield.setAttribute('width', '12');
            windshield.setAttribute('height', '8');
            windshield.setAttribute('fill', '#87CEEB');
            windshield.setAttribute('opacity', '0.6');
            windshield.setAttribute('rx', '1');

            // Roof/cabin area
            const roof = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            roof.setAttribute('x', '13');
            roof.setAttribute('y', '28');
            roof.setAttribute('width', '14');
            roof.setAttribute('height', '16');
            roof.setAttribute('fill', fillColor);
            roof.setAttribute('opacity', '0.5');
            roof.setAttribute('rx', '1');

            // Rear window
            const rearWindow = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rearWindow.setAttribute('x', '14');
            rearWindow.setAttribute('y', '45');
            rearWindow.setAttribute('width', '12');
            rearWindow.setAttribute('height', '6');
            rearWindow.setAttribute('fill', '#87CEEB');
            rearWindow.setAttribute('opacity', '0.6');
            rearWindow.setAttribute('rx', '1');

            // Left side mirror
            const leftMirror = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            leftMirror.setAttribute('cx', '10');
            leftMirror.setAttribute('cy', '28');
            leftMirror.setAttribute('rx', '2');
            leftMirror.setAttribute('ry', '1.5');
            leftMirror.setAttribute('fill', fillColor);

            // Right side mirror
            const rightMirror = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            rightMirror.setAttribute('cx', '30');
            rightMirror.setAttribute('cy', '28');
            rightMirror.setAttribute('rx', '2');
            rightMirror.setAttribute('ry', '1.5');
            rightMirror.setAttribute('fill', fillColor);

            // Front headlights/direction indicator
            const frontIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            frontIndicator.setAttribute('points', '20,4 16,8 24,8');
            frontIndicator.setAttribute('fill', '#FFEB3B');
            frontIndicator.setAttribute('opacity', '0.9');

            // Assemble the car (order matters for layering)
            svg.appendChild(carBody);
            svg.appendChild(hood);
            svg.appendChild(windshield);
            svg.appendChild(roof);
            svg.appendChild(rearWindow);
            svg.appendChild(leftMirror);
            svg.appendChild(rightMirror);
            svg.appendChild(frontIndicator);

            markerEl.appendChild(svg);
            return markerEl;
        }

        // Create simple dot marker element (used for zoom < 16)
        function createSimpleDotMarkerElement(fillColor, borderColor) {
            const markerEl = document.createElement('div');
            markerEl.className = 'user-marker user-marker-dot';
            markerEl.style.width = '20px';
            markerEl.style.height = '20px';
            markerEl.style.borderRadius = '50%';
            markerEl.style.backgroundColor = fillColor;
            markerEl.style.border = `3px solid ${borderColor}`;
            markerEl.style.boxShadow = '0 0 6px rgba(0,0,0,0.4)';
            return markerEl;
        }

        // Track the reference zoom level, current heading, and marker type
        let referenceZoomLevel = null;
        let currentHeading = 0;
        let currentMarkerType = null; // 'car' or 'dot'

        // Update marker rotation based on GPS heading
        function updateMarkerRotation(heading) {
            if (!userMarker) return;

            // Use fallback to 0 (north) if heading unavailable
            if (heading === null || heading === undefined) {
                heading = 0;
            }

            currentHeading = heading;
            updateMarkerTransform();
        }

        // Update marker scale to scale with zoom level (like map features)
        function updateMarkerScale() {
            if (!userMarker || !map) return;

            // Set reference zoom on first call (current zoom when marker is created)
            if (referenceZoomLevel === null) {
                referenceZoomLevel = map.getZoom();
            }

            updateMarkerTransform();
        }

        // Apply both rotation and scale transforms to the marker SVG
        function updateMarkerTransform() {
            if (!userMarker) return;

            const markerEl = userMarker.getElement();
            if (markerEl) {
                const svg = markerEl.querySelector('svg');
                if (svg && currentMarkerType === 'car') {
                    // Only apply scaling and rotation for car icon
                    // Calculate scale factor to scale WITH zoom (like map features)
                    let scaleFactor = 1;
                    if (referenceZoomLevel !== null && map) {
                        const currentZoom = map.getZoom();
                        const zoomDiff = currentZoom - referenceZoomLevel;
                        // Scale with zoom: zooming in = bigger, zooming out = smaller
                        scaleFactor = Math.pow(2, zoomDiff);
                    }

                    // Apply both rotation and scale
                    // IMPORTANT: Don't transform markerEl itself - MapLibre uses that for positioning!
                    svg.style.transform = `rotate(${currentHeading}deg) scale(${scaleFactor})`;
                }
                // Dot doesn't have SVG and doesn't need rotation or scaling
            }
        }

        // Swap between car and dot marker based on zoom level
        function checkAndSwapMarkerType() {
            if (!userMarker || !map) return;

            const currentZoom = map.getZoom();
            const shouldBeCar = currentZoom > 16;
            const desiredType = shouldBeCar ? 'car' : 'dot';

            // Only swap if the type needs to change
            if (currentMarkerType !== desiredType) {
                const currentPos = userMarker.getLngLat();

                // Remove old marker
                userMarker.remove();

                // Create new marker with appropriate type
                let markerEl;
                if (desiredType === 'car') {
                    markerEl = createVehicleMarkerElement(markerFillColor, markerBorderColor);
                    // Set reference zoom ONLY on first car creation (not when swapping back)
                    if (referenceZoomLevel === null) {
                        referenceZoomLevel = currentZoom;
                    }
                } else {
                    markerEl = createSimpleDotMarkerElement(markerFillColor, markerBorderColor);
                    // Keep reference zoom even when switching to dot (for when we swap back to car)
                }

                // Create new marker at same position
                userMarker = new maplibregl.Marker({
                    element: markerEl,
                    anchor: 'center'
                })
                .setLngLat([currentPos.lng, currentPos.lat])
                .addTo(map);

                currentMarkerType = desiredType;

                // Apply initial transform if car
                if (desiredType === 'car') {
                    updateMarkerTransform();
                }
            }
        }

        // Apply custom colors to the marker
        function applyMarkerColors(fillColor, borderColor) {
            // Update global color variables
            markerFillColor = fillColor;
            markerBorderColor = borderColor;

            // If marker doesn't exist yet, colors will be applied when it's created
            if (!userMarker) return;

            const markerEl = userMarker.getElement();
            if (!markerEl) return;

            if (currentMarkerType === 'car') {
                // Update car icon colors
                const gradient = markerEl.querySelector('#carGradient');
                if (gradient) {
                    const stops = gradient.querySelectorAll('stop');
                    if (stops[0]) stops[0].setAttribute('style', `stop-color:${fillColor};stop-opacity:0.8`);
                    if (stops[1]) stops[1].setAttribute('style', `stop-color:${fillColor};stop-opacity:1`);
                    if (stops[2]) stops[2].setAttribute('style', `stop-color:${fillColor};stop-opacity:0.8`);
                }

                // Update main car body stroke (border color)
                const paths = markerEl.querySelectorAll('path');
                if (paths[0]) paths[0].setAttribute('stroke', borderColor); // Main body
                if (paths[1]) paths[1].setAttribute('fill', fillColor); // Hood

                // Update roof color
                const rects = markerEl.querySelectorAll('rect');
                if (rects[2]) rects[2].setAttribute('fill', fillColor); // Roof (third rect)

                // Update side mirrors
                const ellipses = markerEl.querySelectorAll('ellipse');
                ellipses.forEach(mirror => {
                    mirror.setAttribute('fill', fillColor);
                });
            } else if (currentMarkerType === 'dot') {
                // Update simple dot colors
                markerEl.style.backgroundColor = fillColor;
                markerEl.style.border = `3px solid ${borderColor}`;
            }
        }

        function animateMarkerAlongRoad() {
            // Cancel any ongoing animation
            if (markerAnimation) {
                cancelAnimationFrame(markerAnimation);
                markerAnimation = null;
            }

            if (!currentLocation) return;

            const startTime = performance.now();
            let lastUpdateTime = startTime;

            function animate(currentTime) {
                const elapsedSinceLastUpdate = currentTime - lastUpdateTime;
                lastUpdateTime = currentTime;

                // Enhanced stationary detection with time threshold
                const STATIONARY_THRESHOLD = 0.5; // m/s
                const STATIONARY_TIME_THRESHOLD = 3000; // ms

                if (!currentLocation || currentLocation.speed < STATIONARY_THRESHOLD) {
                    if (!stationaryStartTime) {
                        stationaryStartTime = performance.now();
                    }

                    // Stop animation after stationary for 3 seconds
                    if (currentTime - stationaryStartTime > STATIONARY_TIME_THRESHOLD) {
                        markerAnimation = null;
                        isExtrapolating = false;
                    }
                    return;
                } else {
                    stationaryStartTime = null; // Reset when moving
                }

                // Try road-following if we have geometry
                if (roadGeometryCache.currentPosition && roadGeometryCache.currentPosition.segment) {
                    const newPosition = extrapolateAlongRoad(
                        roadGeometryCache.currentPosition,
                        currentLocation.speed,
                        elapsedSinceLastUpdate
                    );

                    if (newPosition) {
                        // Update marker position
                        userMarker.setLngLat([newPosition.lng, newPosition.lat]); // [lng, lat] - REVERSED!

                        // Update rotation if heading is available
                        if (currentLocation && currentLocation.heading !== null) {
                            updateMarkerRotation(currentLocation.heading);
                        }

                        // Update cache
                        roadGeometryCache.currentPosition = newPosition;

                        // Continue animation
                        isExtrapolating = true;
                        markerAnimation = requestAnimationFrame(animate);
                        return;
                    }
                }

                // Fallback: straight-line extrapolation if no road geometry
                if (currentVelocity.lat !== 0 || currentVelocity.lng !== 0) {
                    const currentPos = userMarker.getLngLat(); // Returns {lng, lat}
                    const lat = currentPos.lat + (currentVelocity.lat * elapsedSinceLastUpdate);
                    const lng = currentPos.lng + (currentVelocity.lng * elapsedSinceLastUpdate);

                    userMarker.setLngLat([lng, lat]); // [lng, lat] - REVERSED!

                    // Update rotation if heading is available
                    if (currentLocation && currentLocation.heading !== null) {
                        updateMarkerRotation(currentLocation.heading);
                    }

                    isExtrapolating = true;
                    markerAnimation = requestAnimationFrame(animate);
                }
            }

            markerAnimation = requestAnimationFrame(animate);
        }

        function smoothTransitionTo(targetLat, targetLng, duration = 500) {
            // Cancel ongoing animation
            if (markerAnimation) {
                cancelAnimationFrame(markerAnimation);
                markerAnimation = null;
            }

            const currentPos = userMarker.getLngLat(); // Returns {lng, lat}
            const startLat = currentPos.lat;
            const startLng = currentPos.lng;
            const startTime = performance.now();

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease-out cubic

                const lat = startLat + (targetLat - startLat) * easeProgress;
                const lng = startLng + (targetLng - startLng) * easeProgress;

                userMarker.setLngLat([lng, lat]); // [lng, lat] - REVERSED!

                // Update rotation if heading is available
                if (currentLocation && currentLocation.heading !== null) {
                    updateMarkerRotation(currentLocation.heading);
                }

                if (progress < 1) {
                    markerAnimation = requestAnimationFrame(animate);
                } else {
                    // Transition complete, restart road-following
                    animateMarkerAlongRoad();
                }
            }

            markerAnimation = requestAnimationFrame(animate);
        }

        async function updateMapMarker() {
            if (!currentLocation) return;

            // Use smoothed position for map-matching if available
            const newLat = currentLocation.smoothedLat || currentLocation.lat;
            const newLng = currentLocation.smoothedLng || currentLocation.lng;
            const now = performance.now();

            // Fetch road geometry if needed (every 30 seconds or if moved far)
            const needsGeometryFetch =
                !roadGeometryCache.segments.length ||
                (now - roadGeometryCache.lastFetch > 30000) ||
                (roadGeometryCache.lastFetchLat &&
                 calculateDistance(newLat, newLng, roadGeometryCache.lastFetchLat, roadGeometryCache.lastFetchLng) > 0.5); // > 0.5 miles

            if (needsGeometryFetch) {
                roadGeometryCache.lastFetchLat = newLat;
                roadGeometryCache.lastFetchLng = newLng;
                roadGeometryCache.lastFetch = now;

                // Await the fetch to ensure we have geometry before map-matching
                const segments = await fetchRoadGeometry(newLat, newLng);
                roadGeometryCache.segments = segments;
                console.log(`Road geometry updated: ${segments.length} segments`);
            }

            // Map-match GPS to road
            const matchedPosition = findNearestPointOnRoad(newLat, newLng, roadGeometryCache.segments);

            if (userMarker) {
                // Get current marker position
                const currentLatLng = userMarker.getLngLat(); // Returns {lng, lat}
                const currentLat = currentLatLng.lat;
                const currentLng = currentLatLng.lng;

                // Calculate distance moved (in meters)
                const distanceMovedMeters = calculateDistance(currentLat, currentLng, newLat, newLng);

                // Dynamic jitter threshold based on movement state
                const isStationary = currentLocation.speed < 0.5; // m/s
                const JITTER_THRESHOLD_STATIONARY = 8; // meters when stopped
                const JITTER_THRESHOLD_MOVING = 0.1; // meters when moving (very low to allow smooth updates)

                const jitterThreshold = isStationary ? JITTER_THRESHOLD_STATIONARY : JITTER_THRESHOLD_MOVING;

                if (distanceMovedMeters < jitterThreshold) {
                    // Tiny movement - ignore position update to prevent jitter
                    // Still update rotation even if not moving position
                    if (currentMarkerType === 'car' && currentLocation && currentLocation.heading !== null) {
                        updateMarkerRotation(currentLocation.heading);
                    }
                    console.log(`Ignoring GPS update: distance ${distanceMovedMeters.toFixed(2)}m < threshold ${jitterThreshold}m`);
                    return;
                }

                if (matchedPosition) {
                    // Road-following mode
                    const distanceFromMarkerToMatched = calculateDistance(
                        currentLat, currentLng,
                        matchedPosition.lat, matchedPosition.lng
                    );

                    console.log(`Updating marker: moved ${distanceMovedMeters.toFixed(2)}m, distance to road-matched: ${distanceFromMarkerToMatched.toFixed(2)}m`);

                    // Update road position cache FIRST (so animation uses new target)
                    roadGeometryCache.currentPosition = matchedPosition;
                    roadGeometryCache.currentSegment = matchedPosition.segment;

                    // Calculate velocity for fallback straight-line extrapolation
                    const avgInterval = getAverageGPSInterval();
                    currentVelocity.lat = (matchedPosition.lat - currentLat) / avgInterval;
                    currentVelocity.lng = (matchedPosition.lng - currentLng) / avgInterval;

                    // Handle GPS recovery transition
                    if (currentLocation.requiresSyncTransition) {
                        smoothTransitionTo(matchedPosition.lat, matchedPosition.lng, 2000);
                        currentLocation.requiresSyncTransition = false;
                        return;
                    }

                    // Always use smooth animation, graduated by deviation size
                    if (distanceFromMarkerToMatched > 50) {
                        // Large deviation (>50m) - smooth transition with longer duration
                        smoothTransitionTo(matchedPosition.lat, matchedPosition.lng, 1500);
                        return;
                    } else if (distanceFromMarkerToMatched > 20) {
                        // Medium deviation (>20m) - moderate smooth transition
                        smoothTransitionTo(matchedPosition.lat, matchedPosition.lng, 800);
                        return;
                    }
                    // Small deviations (<20m) - let animation naturally catch up

                    // Ensure animation is running if moving
                    if (currentLocation.speed > 0.5 && !markerAnimation) {
                        animateMarkerAlongRoad();
                    }
                } else {
                    // No road geometry - fallback to straight-line
                    console.log(`No road geometry available, using straight-line transition`);
                    const avgInterval = getAverageGPSInterval();
                    currentVelocity.lat = (newLat - currentLat) / avgInterval;
                    currentVelocity.lng = (newLng - currentLng) / avgInterval;

                    smoothTransitionTo(newLat, newLng, 500);
                }
            } else {
                // First time: create marker
                console.log(`Creating initial marker at ${newLat.toFixed(6)}, ${newLng.toFixed(6)}`);
                const initialLat = matchedPosition ? matchedPosition.lat : newLat;
                const initialLng = matchedPosition ? matchedPosition.lng : newLng;

                // Determine marker type based on initial zoom level
                const initialZoom = map.getZoom();
                let markerEl;
                if (initialZoom > 16) {
                    // Create car icon for zoom > 16
                    markerEl = createVehicleMarkerElement(markerFillColor, markerBorderColor);
                    currentMarkerType = 'car';
                    referenceZoomLevel = initialZoom;
                } else {
                    // Create simple dot for zoom <= 16
                    markerEl = createSimpleDotMarkerElement(markerFillColor, markerBorderColor);
                    currentMarkerType = 'dot';
                }

                userMarker = new maplibregl.Marker({
                    element: markerEl,
                    anchor: 'center'
                })
                .setLngLat([initialLng, initialLat]) // [lng, lat] - REVERSED!
                .addTo(map);

                // Set initial rotation based on GPS heading (only for car)
                if (currentMarkerType === 'car' && currentLocation && currentLocation.heading !== null) {
                    updateMarkerRotation(currentLocation.heading);
                }

                // Initialize marker scale if car
                if (currentMarkerType === 'car') {
                    updateMarkerScale();
                }

                // Enable 3D perspective mode on first GPS lock
                // First check if zoom is sufficient
                const currentZoom = map.getZoom();
                if (currentZoom >= 16) {
                    // Enable perspective mode and auto-rotation
                    perspectiveMode = true;
                    autoRotationEnabled = true;

                    // Apply 3D pitch to the map
                    map.setPitch(45);

                    // Update localStorage
                    localStorage.setItem('perspective_mode', 'true');
                    localStorage.setItem('auto_rotation', 'true');

                    // Update UI
                    const autoRotationCheckbox = document.getElementById('auto-rotation-checkbox');
                    if (autoRotationCheckbox) {
                        autoRotationCheckbox.checked = true;
                    }
                    updatePerspectiveButton();

                    console.log('GPS established - enabling 3D perspective mode with auto-rotation');
                } else {
                    console.log('GPS established - zoom level too low for 3D perspective, staying in 2D mode');
                }

                // Center map on initial position with appropriate offset
                centerMapOnUser(false);

                if (matchedPosition) {
                    roadGeometryCache.currentPosition = matchedPosition;
                    roadGeometryCache.currentSegment = matchedPosition.segment;
                }

                // Start animation if moving
                if (currentLocation.speed > 0.5) {
                    animateMarkerAlongRoad();
                }
            }

            // Re-center map smoothly with appropriate offset for perspective mode
            // Skip if we're in the middle of a perspective toggle animation
            if (!perspectiveToggleInProgress) {
                const targetLat = matchedPosition ? matchedPosition.lat : newLat;
                const targetLng = matchedPosition ? matchedPosition.lng : newLng;

                // Calculate offset based on perspective mode
                let yOffset = 0;
                if (perspectiveMode) {
                    const container = map.getContainer();
                    const containerHeight = container.offsetHeight;
                    yOffset = containerHeight * 0.25;
                }

                map.easeTo({
                    center: [targetLng, targetLat],
                    offset: [0, yOffset],
                    duration: 500
                }); // [lng, lat] - REVERSED!
            }
        }

        // ==================== ROAD INFO QUERY ====================
        async function queryRoadInfo() {
            if (!currentLocation) return;

            try {
                // Use Nominatim reverse geocoding (zoom 18 for detailed road info)
                const url = `https://nominatim.openstreetmap.org/reverse?` +
                    `format=json&lat=${currentLocation.lat}&lon=${currentLocation.lng}&zoom=18&addressdetails=1`;

                const response = await fetch(url, {
                    headers: { 'User-Agent': 'Road Trip Telemetry' }
                });

                if (!response.ok) return;

                const data = await response.json();

                // Extract city from detailed query
                let city = data.address?.city || data.address?.town || data.address?.village || 'Unknown';

                // If city is Unknown, try broader zoom to find nearest city
                if (city === 'Unknown') {
                    try {
                        const broadUrl = `https://nominatim.openstreetmap.org/reverse?` +
                            `format=json&lat=${currentLocation.lat}&lon=${currentLocation.lng}&zoom=10`;

                        const broadResponse = await fetch(broadUrl, {
                            headers: { 'User-Agent': 'Road Trip Telemetry' }
                        });

                        if (broadResponse.ok) {
                            const broadData = await broadResponse.json();
                            const nearestCity = broadData.address?.city ||
                                               broadData.address?.town ||
                                               broadData.address?.village ||
                                               broadData.address?.county;

                            if (nearestCity) {
                                city = `Near ${nearestCity}`;
                            }
                        }
                    } catch (broadError) {
                        console.log('Broad city query failed, keeping Unknown');
                    }
                }

                // Extract highway number and name separately
                // Priority: motorway > trunk > primary > road
                const motorway = data.address?.motorway;
                const trunk = data.address?.trunk;
                const primary = data.address?.primary;
                const road = data.address?.road;

                // Determine which field contains the highway NUMBER
                let highwayNumber = motorway || trunk || primary;

                // If no dedicated highway field, road might be the highway number
                if (!highwayNumber && road) {
                    // Check if road field looks like a highway number
                    const roadLower = road.toLowerCase();
                    if (roadLower.includes('interstate') || roadLower.includes('highway') ||
                        roadLower.match(/^(i-|us-|sr-|sh-|fm\s*\d+)/i)) {
                        highwayNumber = road;
                    }
                }

                // Determine which field contains the highway NAME (not the number)
                let highwayName = null;
                if (road && road !== highwayNumber) {
                    // Road field contains the name, not the number
                    const roadLower = road.toLowerCase();
                    // Make sure it's not also a highway number
                    if (!roadLower.includes('interstate') && !roadLower.includes('highway') &&
                        !roadLower.match(/^(i-|us-|sr-|sh-|fm\s*\d+)/i)) {
                        highwayName = road;
                    }
                }

                roadInfo = {
                    road: highwayNumber || road || 'Unknown',  // The highway number
                    roadName: highwayName || null,  // The highway name (separate)
                    highwayNumber: highwayNumber || null,  // Explicitly store highway number
                    houseNumber: data.address?.house_number || null,
                    city: city,
                    state: data.address?.state || '',
                    type: determineRoadType(data)
                };

                console.log('Road info:', roadInfo);
            } catch (error) {
                console.error('Road query failed:', error);
            }
        }

        function determineRoadType(data) {
            const address = data.address || {};

            // Check motorway field first (most reliable for interstates/highways)
            if (address.motorway) {
                const motorway = address.motorway.toLowerCase();
                if (motorway.includes('interstate')) {
                    return 'Interstate';
                } else {
                    return 'Highway';
                }
            }

            // Check trunk roads (major highways)
            if (address.trunk) {
                return 'Highway';
            }

            // Check primary roads (could be FM/RM roads or state highways)
            if (address.primary) {
                return 'Highway';
            }

            // Fall back to road name string matching
            const road = (address.road || '').toLowerCase();

            if (road.includes('interstate') || road.includes('i-')) {
                return 'Interstate';
            } else if (road.includes('highway') || road.includes('us-') || road.includes('state route') ||
                       road.match(/^fm\s*\d+/i) || road.match(/^rm\s*\d+/i)) {
                return 'Highway';
            } else if (road.includes('freeway') || road.includes('expressway')) {
                return 'Freeway';
            } else if (address.road) {
                return 'Surface Street';
            }

            return 'Unknown';
        }

        function formatHighwayName(name) {
            if (!name) return name;

            let formatted = name;

            // Convert "Interstate 25" ‚Üí "I25"
            // Convert "Interstate 35 E" ‚Üí "I35E"
            formatted = formatted.replace(/Interstate\s+(\d+)\s*([NESW])?/gi, 'I$1$2');

            // Convert "US Highway 287" ‚Üí "US287"
            formatted = formatted.replace(/US\s+Highway\s+(\d+)\s*([NESW])?/gi, 'US$1$2');

            // Convert "State Highway 114" ‚Üí "SH114"
            formatted = formatted.replace(/State\s+Highway\s+(\d+)\s*([NESW])?/gi, 'SH$1$2');

            // Convert "FM 2499" ‚Üí "FM2499" (Farm-to-Market roads)
            formatted = formatted.replace(/FM\s+(\d+)/gi, 'FM$1');

            // Convert "RM 1431" ‚Üí "RM1431" (Ranch-to-Market roads)
            formatted = formatted.replace(/RM\s+(\d+)/gi, 'RM$1');

            // Remove extra spaces
            formatted = formatted.trim().replace(/\s+/g, ' ');

            return formatted;
        }

        function getCardinalDirection(heading) {
            if (heading === null || heading === undefined) return null;

            // Convert heading to cardinal direction (8 directions)
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const index = Math.round(heading / 45) % 8;
            return directions[index];
        }

        // ==================== ROAD GEOMETRY & MAP MATCHING ====================
        async function fetchRoadGeometry(lat, lng, radius = 150) {
            try {
                const query = `
                    [out:json][timeout:5];
                    way(around:${radius},${lat},${lng})["highway"];
                    out geom;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                if (!response.ok) return [];

                const data = await response.json();

                // Parse geometry data
                const segments = data.elements
                    .filter(el => el.type === 'way' && el.geometry && el.geometry.length > 1)
                    .map(el => ({
                        id: el.id,
                        tags: el.tags || {},
                        geometry: el.geometry.map(node => ({
                            lat: node.lat,
                            lng: node.lon
                        }))
                    }));

                console.log(`Fetched ${segments.length} road segments with geometry`);
                return segments;
            } catch (error) {
                console.error('Road geometry fetch failed:', error);
                return [];
            }
        }

        function projectPointOntoLine(pointLat, pointLng, lineStart, lineEnd) {
            // Project point onto line segment and return closest point + progress (0-1)
            const A = {lat: pointLat, lng: pointLng};
            const B = {lat: lineStart.lat, lng: lineStart.lng};
            const C = {lat: lineEnd.lat, lng: lineEnd.lng};

            // Vector BC
            const BC_lat = C.lat - B.lat;
            const BC_lng = C.lng - B.lng;

            // Vector BA
            const BA_lat = A.lat - B.lat;
            const BA_lng = A.lng - B.lng;

            // Dot product
            const dot = BA_lat * BC_lat + BA_lng * BC_lng;

            // Length squared of BC
            const lenSq = BC_lat * BC_lat + BC_lng * BC_lng;

            // Parameter t (0-1) along line segment
            let t = dot / lenSq;

            // Clamp to [0, 1] to stay on line segment
            t = Math.max(0, Math.min(1, t));

            // Calculate projected point
            const projectedLat = B.lat + t * BC_lat;
            const projectedLng = B.lng + t * BC_lng;

            return {
                lat: projectedLat,
                lng: projectedLng,
                progress: t
            };
        }

        function findNearestPointOnRoad(gpsLat, gpsLng, roadSegments) {
            if (!roadSegments || roadSegments.length === 0) return null;

            let nearest = null;
            let minDistance = Infinity;

            for (const segment of roadSegments) {
                for (let i = 0; i < segment.geometry.length - 1; i++) {
                    const p1 = segment.geometry[i];
                    const p2 = segment.geometry[i + 1];

                    // Project GPS point onto this line segment
                    const projected = projectPointOntoLine(gpsLat, gpsLng, p1, p2);
                    const distance = calculateDistance(gpsLat, gpsLng, projected.lat, projected.lng);

                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = {
                            segment: segment,
                            segmentIndex: i,
                            position: projected,
                            lat: projected.lat,
                            lng: projected.lng,
                            progress: projected.progress,
                            distance: distance
                        };
                    }
                }
            }

            return nearest;
        }

        function extrapolateAlongRoad(currentPos, speed, elapsedTime) {
            if (!currentPos || !currentPos.segment) {
                return null;
            }

            // Speed in m/s, elapsedTime in ms
            const distanceToMove = (speed * elapsedTime) / 1000; // meters

            // Convert to degrees (approximate - varies by latitude)
            const degreesToMove = distanceToMove / 111320;

            // Walk along road geometry from current position
            let remainingDistance = degreesToMove;
            let segmentIndex = currentPos.segmentIndex;
            let progress = currentPos.progress;
            const geometry = currentPos.segment.geometry;

            while (remainingDistance > 0 && segmentIndex < geometry.length - 1) {
                const p1 = geometry[segmentIndex];
                const p2 = geometry[segmentIndex + 1];

                // Distance remaining in current segment
                const segmentLength = calculateDistance(p1.lat, p1.lng, p2.lat, p2.lng);
                const remainingInSegment = segmentLength * (1 - progress);

                if (remainingDistance < remainingInSegment) {
                    // Move within current segment
                    progress += remainingDistance / segmentLength;
                    remainingDistance = 0;
                } else {
                    // Move to next segment
                    remainingDistance -= remainingInSegment;
                    segmentIndex++;
                    progress = 0;
                }

                // Safety: don't go past end of road
                if (segmentIndex >= geometry.length - 1) {
                    segmentIndex = geometry.length - 2;
                    progress = 1;
                    break;
                }
            }

            // Interpolate position on segment
            const p1 = geometry[segmentIndex];
            const p2 = geometry[segmentIndex + 1];

            return {
                lat: p1.lat + (p2.lat - p1.lat) * progress,
                lng: p1.lng + (p2.lng - p1.lng) * progress,
                segmentIndex: segmentIndex,
                progress: progress,
                segment: currentPos.segment
            };
        }

        // ==================== SPEED LIMIT QUERY ====================
        async function querySpeedLimit() {
            if (!currentLocation) return;

            try {
                // Query Overpass for nearby ways with maxspeed within 100m (wider search for highways)
                const query = `
                    [out:json][timeout:5];
                    way(around:100,${currentLocation.lat},${currentLocation.lng})["highway"]["maxspeed"];
                    out tags;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                if (!response.ok) return;

                const data = await response.json();

                if (data.elements && data.elements.length > 0) {
                    // Get the first way with maxspeed
                    const way = data.elements[0];
                    let speedLimit = way.tags.maxspeed;

                    if (speedLimit) {
                        // Parse speed limit value
                        speedLimit = parseSpeedLimit(speedLimit);

                        // Update cache with new data - use highway number if available
                        if (roadInfo) {
                            const roadKey = roadInfo.highwayNumber ?
                                formatHighwayName(roadInfo.highwayNumber) :
                                formatHighwayName(roadInfo.road);
                            const direction = getCardinalDirection(currentLocation.heading);

                            speedLimitCache = {
                                value: speedLimit,
                                road: roadKey,
                                direction: direction,
                                isCached: false  // Fresh data, not cached
                            };
                        }

                        // Update roadInfo with speed limit
                        if (roadInfo) {
                            roadInfo.speedLimit = speedLimit;
                        } else {
                            roadInfo = { speedLimit: speedLimit };
                        }

                        console.log('Speed limit found:', speedLimit);
                        return;
                    }
                }

                // No speed limit found - check if we should use cached value
                if (speedLimitCache.value && roadInfo) {
                    // Use highway number if available, otherwise use road
                    const currentRoadKey = roadInfo.highwayNumber ?
                        formatHighwayName(roadInfo.highwayNumber) :
                        (roadInfo.road ? formatHighwayName(roadInfo.road) : null);

                    if (currentRoadKey) {
                        // KEEP cached value if we're on the same road (ignore direction changes)
                        if (speedLimitCache.road === currentRoadKey) {
                            // Same road - keep showing speed limit regardless of direction
                            roadInfo.speedLimit = speedLimitCache.value;
                            speedLimitCache.isCached = true;  // Mark as cached
                            console.log('Using cached speed limit:', speedLimitCache.value, 'for', currentRoadKey);
                            return;
                        } else {
                            // Different road - clear the speed limit (changed roads via turn/ramp)
                            console.log('Road changed from', speedLimitCache.road, 'to', currentRoadKey, '- clearing speed limit');
                            roadInfo.speedLimit = null;
                            speedLimitCache.isCached = false;
                        }
                    } else {
                        // No current road info - clear speed limit display
                        roadInfo.speedLimit = null;
                        speedLimitCache.isCached = false;
                    }
                } else {
                    // No cache available - clear speed limit display
                    if (roadInfo) {
                        roadInfo.speedLimit = null;
                    }
                    speedLimitCache.isCached = false;
                }

            } catch (error) {
                console.error('Speed limit query failed:', error);

                // On error, try to use cached value if available and on same road
                if (speedLimitCache.value && roadInfo) {
                    const currentRoadKey = roadInfo.highwayNumber ?
                        formatHighwayName(roadInfo.highwayNumber) :
                        (roadInfo.road ? formatHighwayName(roadInfo.road) : null);

                    if (currentRoadKey && speedLimitCache.road === currentRoadKey) {
                        roadInfo.speedLimit = speedLimitCache.value;
                        speedLimitCache.isCached = true;
                        console.log('Using cached speed limit (error fallback):', speedLimitCache.value);
                    }
                }
            }
        }

        function parseSpeedLimit(maxspeedValue) {
            // Parse maxspeed tag value into mph
            // Examples: "55 mph", "100" (km/h), "50 knots"

            const value = maxspeedValue.trim();

            // Check for mph
            if (value.includes('mph')) {
                return parseInt(value);
            }

            // Check for knots
            if (value.includes('knots')) {
                const knots = parseInt(value);
                return Math.round(knots * 1.15078); // Convert knots to mph
            }

            // Default is km/h - convert to mph
            const kmh = parseInt(value);
            if (!isNaN(kmh)) {
                return Math.round(kmh * 0.621371);
            }

            return null;
        }

        // ==================== NEARBY EXITS QUERY ====================
        async function getRoadNameForExit(lat, lng) {
            try {
                const url = `https://nominatim.openstreetmap.org/reverse?` +
                    `format=json&lat=${lat}&lon=${lng}&zoom=18`;

                const response = await fetch(url, {
                    headers: { 'User-Agent': 'Road Trip Telemetry' }
                });

                if (!response.ok) return null;

                const data = await response.json();

                // Look for the most relevant road name
                const address = data.address || {};

                // Priority: road > street > residential > highway
                const roadName = address.road ||
                                address.street ||
                                address.residential ||
                                address.highway ||
                                address.motorway;

                return roadName || null;
            } catch (error) {
                console.error('Geocoding failed for exit:', error);
                return null;
            }
        }

        async function queryNearbyExits() {
            if (!currentLocation) return;

            try {
                // Query Overpass for motorway junctions within 800m (0.5 mi)
                const query = `
                    [out:json][timeout:5];
                    (
                        node["highway"="motorway_junction"](around:800,${currentLocation.lat},${currentLocation.lng});
                    );
                    out body;
                    >;
                    out skel qt;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                if (!response.ok) return;

                const data = await response.json();

                const exitNodes = data.elements
                    .filter(element => element.type === 'node' && element.tags)
                    .map(element => {
                        const distance = calculateDistance(
                            currentLocation.lat,
                            currentLocation.lng,
                            element.lat,
                            element.lon
                        );

                        return {
                            id: element.id,
                            lat: element.lat,
                            lng: element.lon,
                            distance: distance,
                            tags: element.tags,
                            needsGeocode: !element.tags.ref && !element.tags.name && !element.tags.destination
                        };
                    });

                // Fetch street names for unnamed exits
                const exitPromises = exitNodes.map(async (element) => {
                    let exitName = 'Exit';
                    let destination = null;

                    // Build exit name with multiple fallbacks
                    if (element.tags.ref) {
                        exitName = `Exit ${element.tags.ref}`;
                    } else if (element.tags.name) {
                        exitName = element.tags.name;
                    } else if (element.tags.destination) {
                        exitName = `Exit to ${element.tags.destination}`;
                        destination = element.tags.destination;
                    } else if (element.needsGeocode) {
                        // Fetch street name via reverse geocoding
                        const streetName = await getRoadNameForExit(element.lat, element.lng);
                        if (streetName) {
                            exitName = `Exit towards ${streetName}`;
                        } else {
                            exitName = 'Exit (unsigned)';
                        }
                    } else if (element.tags['noref'] === 'yes' || element.tags['unsigned_ref']) {
                        exitName = `Exit ${element.tags.unsigned_ref || '(unsigned)'}`;
                    }

                    // Add destination info if available and not already set
                    if (!destination) {
                        if (element.tags.destination) {
                            destination = element.tags.destination;
                        } else if (element.tags['destination:ref']) {
                            destination = element.tags['destination:ref'];
                        } else if (element.tags['destination:street']) {
                            destination = element.tags['destination:street'];
                        }
                    }

                    // Determine if this is an exit (off-ramp) or entrance (on-ramp)
                    // motorway_junction nodes are ALWAYS exits (leaving the motorway)
                    // Only mark as entrance if explicitly tagged as such
                    const isEntrance = element.tags.highway === 'motorway_link' &&
                                      !element.tags.destination &&
                                      !element.tags['destination:ref'] &&
                                      !element.tags['destination:street'];
                    const isExit = !isEntrance;  // Default to exit for motorway_junction nodes

                    return {
                        id: element.id,
                        name: exitName,
                        destination: destination,
                        ref: element.tags.ref || null,
                        lat: element.lat,
                        lng: element.lng,
                        distance: element.distance,
                        tags: element.tags,
                        type: isExit ? 'exit' : 'entrance'  // NEW: Add type classification
                    };
                });

                nearbyExits = await Promise.all(exitPromises);

                // Sort by distance
                nearbyExits.sort((a, b) => a.distance - b.distance);

                console.log('Nearby exits found:', nearbyExits.length);
                updateExitsDisplay();
            } catch (error) {
                console.error('Exit query failed:', error);
            }
        }

        // ==================== WEATHER QUERY ====================
        async function queryWeather() {
            if (!currentLocation) return;

            try {
                // Use Open-Meteo API (completely free, no API key needed, real data)
                const url = `https://api.open-meteo.com/v1/forecast?` +
                    `latitude=${currentLocation.lat}&` +
                    `longitude=${currentLocation.lng}&` +
                    `current=temperature_2m,apparent_temperature,relative_humidity_2m,weather_code,wind_speed_10m,wind_direction_10m,wind_gusts_10m,precipitation&` +
                    `daily=sunrise,sunset&` +
                    `timezone=auto&` +
                    `temperature_unit=fahrenheit&` +
                    `wind_speed_unit=mph&` +
                    `precipitation_unit=inch`;

                const response = await fetch(url);
                if (!response.ok) return;

                const data = await response.json();
                const current = data.current;
                const daily = data.daily;

                weatherData = {
                    temp: current.temperature_2m,
                    feelsLike: current.apparent_temperature,
                    humidity: current.relative_humidity_2m,
                    windSpeed: current.wind_speed_10m,
                    windGust: current.wind_gusts_10m,
                    windDirection: current.wind_direction_10m,
                    precipitation: current.precipitation || 0,
                    weatherCode: current.weather_code,  // Store numeric weather code
                    condition: getWeatherCondition(current.weather_code),
                    sunrise: daily.sunrise[0],  // Today's sunrise (ISO 8601 format)
                    sunset: daily.sunset[0]     // Today's sunset (ISO 8601 format)
                };

                updateWeatherDisplay();

                // Update rain animation based on weather code and precipitation
                console.log('Weather code:', current.weather_code, 'Precipitation:', current.precipitation, 'Condition:', weatherData.condition);
                updateRainAnimation(current.weather_code, current.precipitation);

                console.log('Weather updated:', weatherData);
            } catch (error) {
                console.error('Weather query failed:', error);
            }
        }

        function getWeatherCondition(code) {
            // WMO Weather interpretation codes
            const conditions = {
                0: 'Clear',
                1: 'Mostly Clear',
                2: 'Partly Cloudy',
                3: 'Cloudy',
                45: 'Foggy',
                48: 'Rime Fog',
                51: 'Light Drizzle',
                53: 'Drizzle',
                55: 'Heavy Drizzle',
                61: 'Light Rain',
                63: 'Rain',
                65: 'Heavy Rain',
                71: 'Light Snow',
                73: 'Snow',
                75: 'Heavy Snow',
                77: 'Snow Grains',
                80: 'Light Showers',
                81: 'Showers',
                82: 'Heavy Showers',
                85: 'Light Snow Showers',
                86: 'Snow Showers',
                95: 'Thunderstorm',
                96: 'Thunderstorm w/ Hail',
                99: 'Severe Thunderstorm'
            };
            return conditions[code] || 'Unknown';
        }

        function getWindDirection(degrees) {
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
                                'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round(degrees / 22.5) % 16;
            return 'From ' + directions[index];
        }

        function updateWeatherDisplay() {
            if (!weatherData) return;

            document.getElementById('weather-temp').textContent = weatherData.temp.toFixed(0);
            document.getElementById('weather-feels').textContent = weatherData.feelsLike.toFixed(0);
            document.getElementById('weather-humidity').textContent = weatherData.humidity;
            document.getElementById('weather-wind').textContent = weatherData.windSpeed.toFixed(0);

            // Display wind gust
            if (weatherData.windGust !== null && weatherData.windGust !== undefined) {
                document.getElementById('weather-wind-gust').innerHTML = `Gusts <span style="color: #f97316;">${weatherData.windGust.toFixed(0)}</span> mph`;
            } else {
                document.getElementById('weather-wind-gust').textContent = 'No gusts';
            }

            document.getElementById('weather-wind-dir').textContent = getWindDirection(weatherData.windDirection);
            document.getElementById('weather-condition').textContent = weatherData.condition;

            // Rotate wind arrow to show where wind is blowing (opposite of where it's coming from)
            // If wind is "From SSE" (157.5¬∞), arrow points NNW (157.5¬∞ + 180¬∞ = 337.5¬∞)
            const windArrow = document.getElementById('wind-arrow');
            if (weatherData.windDirection !== null && weatherData.windDirection !== undefined) {
                windArrow.style.transform = `rotate(${weatherData.windDirection + 180}deg)`;
                windArrow.style.opacity = '1';
            } else {
                windArrow.style.opacity = '0.3';
            }

            // Update sunrise/sunset
            if (weatherData.sunrise && weatherData.sunset) {
                const now = new Date();
                const sunrise = new Date(weatherData.sunrise);
                const sunset = new Date(weatherData.sunset);
                const sunsetPlus30 = new Date(sunset.getTime() + 30 * 60 * 1000); // 30 minutes after sunset

                const sunLabelEl = document.getElementById('sun-label');
                const sunTimeEl = document.getElementById('sun-time');

                // Determine what to show based on time of day
                if (now < sunrise) {
                    // Before sunrise - show sunrise
                    sunLabelEl.textContent = 'Sunrise';
                    sunTimeEl.textContent = formatTime(sunrise);
                    sunTimeEl.style.opacity = '1';
                    sunTimeEl.style.color = '#f97316';
                } else if (now >= sunrise && now < sunset) {
                    // After sunrise, before sunset - show sunset
                    sunLabelEl.textContent = 'Sunset';
                    sunTimeEl.textContent = formatTime(sunset);
                    sunTimeEl.style.opacity = '1';
                    sunTimeEl.style.color = '#f97316';
                } else if (now >= sunset && now < sunsetPlus30) {
                    // Within 30 minutes after sunset - show sunset with different styling
                    sunLabelEl.textContent = 'Sunset (passed)';
                    sunTimeEl.textContent = formatTime(sunset);
                    sunTimeEl.style.opacity = '0.6';
                    sunTimeEl.style.color = '#999';
                } else {
                    // More than 30 minutes after sunset - show next sunrise
                    sunLabelEl.textContent = 'Sunrise (tomorrow)';
                    const tomorrowSunrise = new Date(sunrise.getTime() + 24 * 60 * 60 * 1000);
                    sunTimeEl.textContent = formatTime(tomorrowSunrise);
                    sunTimeEl.style.opacity = '1';
                    sunTimeEl.style.color = '#f97316';
                }
            }
        }

        function formatTime(date) {
            // Format as 12-hour time (e.g., "6:45 PM")
            let hours = date.getHours();
            const minutes = date.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // 0 should be 12
            const minutesStr = minutes < 10 ? '0' + minutes : minutes;
            return `${hours}:${minutesStr} ${ampm}`;
        }

        // ==================== RADAR OVERLAY ====================
        async function loadRadar() {
            try {
                // Fetch latest radar data from RainViewer API
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                if (!response.ok) {
                    console.error('Failed to fetch radar data');
                    return;
                }

                const data = await response.json();

                // Get the latest radar frame (most recent past frame)
                if (!data.radar || !data.radar.past || data.radar.past.length === 0) {
                    console.error('No radar data available');
                    return;
                }

                // Use the most recent frame
                const latestFrame = data.radar.past[data.radar.past.length - 1];

                // Construct tile URL
                const tileUrl = `${data.host}${latestFrame.path}/256/{z}/{x}/{y}/6/1_1.png`;

                // Remove existing radar layer/source if present
                if (map.getLayer('radar-layer')) {
                    map.removeLayer('radar-layer');
                }
                if (map.getSource('radar')) {
                    map.removeSource('radar');
                }

                // Add radar source (with CORS support)
                map.addSource('radar', {
                    type: 'raster',
                    tiles: [tileUrl],
                    tileSize: 256,
                    minzoom: 0,
                    maxzoom: 8  // RainViewer provides tiles up to zoom 8
                });

                // Get current opacity from slider
                const slider = document.getElementById('radar-opacity-slider');
                const currentOpacity = slider ? slider.value / 100 : 0.6;

                // Find first symbol layer (for proper stacking above terrain, below labels)
                const layers = map.getStyle().layers;
                const firstSymbolLayer = layers.find(l => l.type === 'symbol');

                // Add radar layer
                map.addLayer({
                    id: 'radar-layer',
                    type: 'raster',
                    source: 'radar',
                    paint: {
                        'raster-opacity': currentOpacity
                    }
                }, firstSymbolLayer ? firstSymbolLayer.id : undefined);

                radarLayerVisible = true;
                console.log('Radar overlay loaded successfully');
            } catch (error) {
                console.error('Error loading radar:', error);
                radarLayerVisible = false;
            }
        }

        // Refresh radar data periodically (every 2 minutes)
        function startRadarRefresh() {
            setInterval(() => {
                console.log('Refreshing radar data...');
                loadRadar();
            }, 120000); // 2 minutes
        }

        // Check if radar layer is visible to user
        function isRadarVisible() {
            if (!map || !map.getLayer('radar-layer')) return false;

            const opacity = map.getPaintProperty('radar-layer', 'raster-opacity');

            // Radar is visible if layer exists and opacity > 0
            return opacity > 0;
        }

        // Periodically check for rain animation
        function startRadarRainCheck() {
            // Check for rain every 30 seconds
            setInterval(() => {
                if (weatherData) {
                    // Re-evaluate rain animation with current data
                    const weatherCode = weatherData.weatherCode;  // Use numeric code, not string condition
                    const precipitation = weatherData.precipitation;
                    updateRainAnimation(weatherCode, precipitation);
                }
            }, 30000); // 30 seconds
        }

        // ==================== OVERPASS HEIGHT DETECTION ====================

        // Get vehicle clearance requirement
        function getVehicleClearance() {
            const vehicleType = localStorage.getItem('vehicle_type') || 'car';
            const clearances = {
                'car': null,        // No restrictions
                'suv': null,        // No restrictions
                'rv': 3.35,         // 11 feet in meters
                'truck': 4.11       // 13'6" in meters
            };
            return clearances[vehicleType];
        }

        // Fetch overpass/bridge data from OpenStreetMap
        async function fetchNearbyOverpasses(lat, lng, radiusMeters = 2000) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';

            // Query for bridges and tunnels with height data
            // OSM tags: maxheight, maxheight:physical, height
            const query = `
            [out:json][timeout:25];
            (
              way["bridge"="yes"]["maxheight"](around:${radiusMeters},${lat},${lng});
              way["bridge"="yes"]["maxheight:physical"](around:${radiusMeters},${lat},${lng});
              way["tunnel"="yes"]["maxheight"](around:${radiusMeters},${lat},${lng});
              way["highway"]["maxheight"](around:${radiusMeters},${lat},${lng});
            );
            out body;
            >;
            out skel qt;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    body: query,
                    headers: { 'Content-Type': 'text/plain' }
                });

                if (!response.ok) {
                    throw new Error(`Overpass API error: ${response.status}`);
                }

                const data = await response.json();
                return parseOverpassData(data, lat, lng);
            } catch (error) {
                console.error('Error fetching overpass data:', error);
                return [];
            }
        }

        // Parse Overpass API response
        function parseOverpassData(data, userLat, userLng) {
            const overpasses = [];
            const ways = data.elements.filter(el => el.type === 'way');
            const nodes = data.elements.filter(el => el.type === 'node');

            for (const way of ways) {
                // Extract height from tags
                const maxheight = way.tags?.maxheight || way.tags?.['maxheight:physical'];
                if (!maxheight) continue;

                // Parse height (can be "4.5", "4.5 m", "14'6\"", etc.)
                const heightMeters = parseHeight(maxheight);
                if (!heightMeters) continue;

                // Calculate center point of the way
                const wayNodes = way.nodes
                    .map(nodeId => nodes.find(n => n.id === nodeId))
                    .filter(n => n && n.lat && n.lon);

                if (wayNodes.length === 0) continue;

                const centerLat = wayNodes.reduce((sum, n) => sum + n.lat, 0) / wayNodes.length;
                const centerLng = wayNodes.reduce((sum, n) => sum + n.lon, 0) / wayNodes.length;

                // Calculate distance from user
                const distance = calculateDistance(userLat, userLng, centerLat, centerLng);

                overpasses.push({
                    id: way.id,
                    name: way.tags?.name || way.tags?.highway || 'Unnamed overpass',
                    lat: centerLat,
                    lng: centerLng,
                    heightMeters: heightMeters,
                    heightFeet: (heightMeters * 3.28084).toFixed(1),
                    distance: distance,
                    isBridge: way.tags?.bridge === 'yes',
                    isTunnel: way.tags?.tunnel === 'yes',
                    highway: way.tags?.highway
                });
            }

            // Sort by distance
            overpasses.sort((a, b) => a.distance - b.distance);

            return overpasses;
        }

        // Parse height string to meters
        function parseHeight(heightStr) {
            if (!heightStr) return null;

            // Remove whitespace
            const str = heightStr.trim();

            // Feet and inches (e.g., "14'6\"" or "14' 6\"")
            const feetInchMatch = str.match(/(\d+)'?\s*(\d+)?"?/);
            if (feetInchMatch) {
                const feet = parseInt(feetInchMatch[1]);
                const inches = feetInchMatch[2] ? parseInt(feetInchMatch[2]) : 0;
                return ((feet * 12) + inches) * 0.0254; // Convert to meters
            }

            // Just feet (e.g., "14'" or "14 ft")
            const feetMatch = str.match(/(\d+\.?\d*)\s*'|ft|feet/i);
            if (feetMatch) {
                return parseFloat(feetMatch[1]) * 0.3048;
            }

            // Meters (e.g., "4.5" or "4.5 m")
            const metersMatch = str.match(/(\d+\.?\d*)\s*m?/i);
            if (metersMatch) {
                return parseFloat(metersMatch[1]);
            }

            return null;
        }

        // Calculate distance between two points (Haversine formula)
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371000; // Earth radius in meters
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lng2 - lng1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // Distance in meters
        }

        // Display overpass alert
        function showOverpassAlert(overpass) {
            // Remove existing alert
            if (activeOverpassAlert) {
                activeOverpassAlert.remove();
                activeOverpassAlert = null;
            }

            const vehicleClearance = getVehicleClearance();
            const vehicleType = localStorage.getItem('vehicle_type') || 'car';

            // Determine alert level
            let alertLevel = 'normal';
            let alertIcon = '‚ÑπÔ∏è';
            let title = 'Overpass Ahead';

            if (vehicleClearance !== null) {
                if (overpass.heightMeters < vehicleClearance) {
                    alertLevel = 'danger';
                    alertIcon = '‚ö†Ô∏è';
                    title = 'LOW CLEARANCE WARNING!';
                } else if (overpass.heightMeters < vehicleClearance + 0.5) {
                    alertLevel = 'warning';
                    alertIcon = '‚ö°';
                    title = 'Tight Clearance Alert';
                }
            }

            // Create alert element
            const alert = document.createElement('div');
            alert.className = `overpass-alert ${alertLevel}`;
            alert.innerHTML = `
                <div class="overpass-alert-title">${alertIcon} ${title}</div>
                <div class="overpass-alert-details">
                    ${overpass.name}<br>
                    Clearance: ${overpass.heightFeet}' (${overpass.heightMeters.toFixed(2)}m)<br>
                    Distance: ${(overpass.distance / 1609.34).toFixed(2)} miles
                </div>
            `;

            document.body.appendChild(alert);
            activeOverpassAlert = alert;

            // Auto-dismiss after 8 seconds for normal alerts, 15 for warnings/danger
            const dismissTime = alertLevel === 'normal' ? 8000 : 15000;
            setTimeout(() => {
                if (alert === activeOverpassAlert) {
                    alert.style.animation = 'slideDown 0.3s ease-out reverse';
                    setTimeout(() => {
                        alert.remove();
                        if (activeOverpassAlert === alert) {
                            activeOverpassAlert = null;
                        }
                    }, 300);
                }
            }, dismissTime);
        }

        // Check for nearby overpasses
        async function checkNearbyOverpasses(lat, lng) {
            // Only check if position changed significantly (100m)
            if (lastOverpassCheck) {
                const dist = calculateDistance(
                    lastOverpassCheck.lat,
                    lastOverpassCheck.lng,
                    lat,
                    lng
                );
                if (dist < 100) return; // Too close to last check
            }

            lastOverpassCheck = { lat, lng };

            // Fetch overpasses within 2km
            nearbyOverpasses = await fetchNearbyOverpasses(lat, lng, 2000);

            console.log(`Found ${nearbyOverpasses.length} overpasses nearby`);

            // Show alert for closest overpass within 800m (0.5 miles)
            const closeOverpass = nearbyOverpasses.find(op => op.distance <= 800);

            if (closeOverpass) {
                showOverpassAlert(closeOverpass);
            }
        }

        // ==================== 3D PERSPECTIVE VIEW ====================

        // Center map on user's current location with appropriate offset for perspective mode
        function centerMapOnUser(animated = true) {
            if (!currentLocation || !map) return;

            const duration = animated ? 800 : 0;

            if (perspectiveMode) {
                // In 3D mode: Position user at bottom 25% (75% from top)
                // This gives more view ahead in the direction of travel
                const container = map.getContainer();
                const containerHeight = container.offsetHeight;

                // Calculate offset: move center up by 25% of viewport height
                // Positive Y offset shifts view up (user appears lower on screen)
                const yOffset = containerHeight * 0.25;

                // Use current pitch and bearing (should be 45 and rotating)
                map.easeTo({
                    center: [currentLocation.lng, currentLocation.lat],
                    offset: [0, yOffset],
                    pitch: 45,
                    bearing: map.getBearing(),
                    duration: duration
                });
            } else {
                // In 2D mode: Center user in the middle of the screen
                // Always use pitch 0 and bearing 0 in 2D mode
                map.easeTo({
                    center: [currentLocation.lng, currentLocation.lat],
                    offset: [0, 0],
                    pitch: 0,
                    bearing: 0,
                    duration: duration
                });
            }
        }

        // Enable 3D perspective mode
        function enablePerspectiveMode() {
            // Check if zoom level allows perspective mode
            const currentZoom = map.getZoom();
            if (currentZoom < 16) {
                console.warn('Cannot enable 3D perspective: zoom level must be >= 16');
                return;
            }

            perspectiveMode = true;
            perspectiveToggleInProgress = true;

            // Calculate center and offset for 3D mode
            const container = map.getContainer();
            const containerHeight = container.offsetHeight;
            const yOffset = containerHeight * 0.25;

            // Determine bearing
            const bearing = (autoRotationEnabled && lastBearing !== null) ? lastBearing : 0;

            // Combine all animations into a single easeTo call to prevent conflicts
            if (currentLocation) {
                map.easeTo({
                    pitch: 45,
                    bearing: bearing,
                    center: [currentLocation.lng, currentLocation.lat],
                    offset: [0, yOffset],
                    duration: 800
                });
            } else {
                // No location yet, just set pitch and bearing
                map.easeTo({
                    pitch: 45,
                    bearing: bearing,
                    duration: 800
                });
            }

            // Save to localStorage
            localStorage.setItem('perspective_mode', 'true');

            // Update UI
            updatePerspectiveButton();

            // Clear toggle flag after animation completes
            setTimeout(() => {
                perspectiveToggleInProgress = false;
            }, 800);

            // Check house number visibility after enabling perspective
            checkHouseNumberVisibility();

            console.log('3D Perspective mode enabled');
        }

        // Disable 3D perspective mode
        function disablePerspectiveMode() {
            perspectiveMode = false;
            perspectiveToggleInProgress = true;

            // Combine all animations into a single easeTo call to prevent conflicts
            if (currentLocation) {
                map.easeTo({
                    pitch: 0,
                    bearing: 0,
                    center: [currentLocation.lng, currentLocation.lat],
                    offset: [0, 0],  // No offset in 2D mode
                    duration: 800
                });
            } else {
                // No location yet, just reset pitch and bearing
                map.easeTo({
                    pitch: 0,
                    bearing: 0,
                    duration: 800
                });
            }

            // Save to localStorage
            localStorage.setItem('perspective_mode', 'false');

            // Update UI
            updatePerspectiveButton();

            // Clear toggle flag after animation completes
            setTimeout(() => {
                perspectiveToggleInProgress = false;
            }, 800);

            // Check house number visibility after disabling perspective
            checkHouseNumberVisibility();

            console.log('2D Map mode enabled');
        }

        // Toggle between 2D and 3D modes
        function togglePerspectiveMode() {
            console.log(`Toggle called - perspectiveMode: ${perspectiveMode}, perspectiveDisabledByZoom: ${perspectiveDisabledByZoom}`);

            // Clear auto-disable flag when user manually toggles
            perspectiveDisabledByZoom = false;

            if (perspectiveMode) {
                console.log('Calling disablePerspectiveMode()');
                disablePerspectiveMode();
            } else {
                console.log('Calling enablePerspectiveMode()');
                enablePerspectiveMode();
            }
        }

        // Update perspective button appearance based on current mode
        function updatePerspectiveButton() {
            const button = document.getElementById('perspective-toggle');
            const checkbox = document.getElementById('auto-rotation-checkbox');

            if (!button) return;

            if (perspectiveMode) {
                // 3D mode - orange/active styling
                button.style.background = 'linear-gradient(135deg, #f97316, #ea580c)';
                button.style.color = 'white';
                button.style.borderColor = '#f97316';
                button.innerHTML = 'üß≠ 3D Perspective (Forward View)';

                // Enable auto-rotation checkbox
                checkbox.disabled = false;
                checkbox.checked = autoRotationEnabled;
                checkbox.parentElement.parentElement.querySelector('label').style.color = '#e0e0e0';
            } else {
                // 2D mode - gray/inactive styling
                button.style.background = '#3a3a3a';
                button.style.color = '#999';
                button.style.borderColor = '#444';
                button.innerHTML = 'üó∫Ô∏è 2D Map View (North Up)';

                // Disable auto-rotation checkbox
                checkbox.disabled = true;
                checkbox.parentElement.parentElement.querySelector('label').style.color = '#999';

                // Only modify auto-rotation state if this is a manual disable (not auto-disabled by zoom)
                if (!perspectiveDisabledByZoom) {
                    checkbox.checked = false;
                    autoRotationEnabled = false;
                    localStorage.setItem('auto_rotation', 'false');
                } else {
                    // Keep checkbox showing saved state during auto-disable
                    checkbox.checked = savedAutoRotationState;
                }
            }
        }

        // Update map bearing based on GPS heading
        function updateMapBearing(heading) {
            if (!perspectiveMode || !autoRotationEnabled) return;
            if (heading === null || heading === undefined) return;

            // Only update if bearing changed significantly (> 5 degrees) to prevent jitter
            if (lastBearing !== null && Math.abs(heading - lastBearing) < 5) {
                return;
            }

            lastBearing = heading;

            // Smoothly rotate map to match heading
            map.easeTo({
                bearing: heading,
                duration: 300
            });
        }

        // Check if auto-rotation should be active based on speed
        function checkAutoRotation(currentSpeed, heading) {
            if (!perspectiveMode || !autoRotationEnabled) return;

            const speedMPH = currentSpeed * 2.23694; // Convert m/s to MPH

            // Only rotate when driving (> 5 MPH)
            if (speedMPH > 5) {
                updateMapBearing(heading);
            }
        }

        // ==================== DECORATIVE TREES ====================
        // Seeded random number generator for deterministic tree placement
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // Generate a seed from lat/lng coordinates
        function coordToSeed(lat, lng) {
            return lat * 1000000 + lng * 1000000;
        }

        // Helper: Check if location is suitable for a tree (park, green space, not road/building/water)
        function isValidTreeLocation(lng, lat) {
            // Convert lat/lng to screen coordinates
            const point = map.project([lng, lat]);

            // Query features at this point
            const features = map.queryRenderedFeatures(point);

            if (!features || features.length === 0) {
                return true; // Empty space is OK for trees
            }

            // Check what features exist at this location
            let hasRoad = false;
            let hasBuilding = false;
            let hasWater = false;

            for (const feature of features) {
                const layer = feature.layer;
                const props = feature.properties || {};
                const sourceLayer = feature.sourceLayer || '';

                // Check for roads/highways
                if (layer.id.includes('road') || layer.id.includes('highway') ||
                    layer.id.includes('street') || layer.id.includes('transportation') ||
                    sourceLayer.includes('road') || sourceLayer.includes('transportation')) {
                    hasRoad = true;
                }

                // Check for buildings
                if (layer.id.includes('building') || sourceLayer.includes('building') ||
                    props.building) {
                    hasBuilding = true;
                }

                // Check for water
                if (layer.id.includes('water') || sourceLayer.includes('water') ||
                    props.water || props.waterway) {
                    hasWater = true;
                }
            }

            // Never place on roads, buildings, or water
            if (hasRoad || hasBuilding || hasWater) {
                return false;
            }

            return true; // Valid location
        }

        // Create a tree marker at specific coordinates
        function createTreeMarker(lng, lat, treeEmoji) {
            const treeEl = document.createElement('div');
            treeEl.className = 'decorative-tree';
            treeEl.style.fontSize = '50px'; // Fixed pixel size - won't change with zoom
            treeEl.style.cursor = 'default';
            treeEl.style.userSelect = 'none';
            treeEl.style.pointerEvents = 'none';
            treeEl.textContent = treeEmoji;

            const treeMarker = new maplibregl.Marker({
                element: treeEl,
                anchor: 'bottom',
                pitchAlignment: 'viewport',
                rotationAlignment: 'viewport'
            })
            .setLngLat([lng, lat])
            .addTo(map);

            return treeMarker;
        }

        // Update trees based on current viewport
        function updateDecorativeTrees(themeName) {
            // Only show trees for cartoon and holiday themes AND zoom >= 16
            const currentZoom = map ? map.getZoom() : 0;
            const shouldShowTrees = themeName && (
                themeName.includes('cartoon') ||
                themeName.includes('holiday')
            ) && currentZoom >= 16;

            if (!shouldShowTrees || !map || !currentLocation) {
                // Clear all trees if wrong theme, no GPS, or zoom too low
                decorativeTreeMarkers.forEach(marker => marker.remove());
                decorativeTreeMarkers.clear();
                lastTreeUpdateLocation = null;
                return;
            }

            // Only update trees if we've moved significantly (> 0.1 miles)
            if (lastTreeUpdateLocation) {
                const distanceMoved = calculateDistance(
                    lastTreeUpdateLocation.lat,
                    lastTreeUpdateLocation.lng,
                    currentLocation.lat,
                    currentLocation.lng
                );
                if (distanceMoved < 0.1) {
                    return; // Not far enough, keep existing trees
                }
            }

            // Update last tree location
            lastTreeUpdateLocation = {
                lat: currentLocation.lat,
                lng: currentLocation.lng
            };

            // Determine which emoji to use
            const treeEmoji = themeName.includes('holiday') ? 'üéÑ' : 'üå≤';

            // Constants
            const TREE_COUNT = 40;
            const RADIUS_MILES = 1;
            const RADIUS_DEGREES = RADIUS_MILES / 69; // Approximate conversion (69 miles per degree at equator)

            // Use GPS location as center
            const centerLat = currentLocation.lat;
            const centerLng = currentLocation.lng;

            // Create deterministic seed based on GPS location (rounded to avoid jitter)
            const locationSeed = coordToSeed(
                Math.round(centerLat * 1000) / 1000,
                Math.round(centerLng * 1000) / 1000
            );

            // Generate 40 tree positions
            const treePositions = [];
            for (let i = 0; i < TREE_COUNT; i++) {
                // Use seeded random for deterministic placement
                const seed = locationSeed + i;

                // Random angle (0-360 degrees)
                const angle = seededRandom(seed) * 2 * Math.PI;

                // Random distance (0 to RADIUS_DEGREES)
                // Use square root for uniform distribution in a circle
                const distance = Math.sqrt(seededRandom(seed + 100)) * RADIUS_DEGREES;

                // Calculate position
                let treeLng = centerLng + distance * Math.cos(angle);
                let treeLat = centerLat + distance * Math.sin(angle);

                // Check if tree is outside the radius and clamp to edge if needed
                const actualDistance = Math.sqrt(
                    Math.pow(treeLng - centerLng, 2) + Math.pow(treeLat - centerLat, 2)
                );

                if (actualDistance > RADIUS_DEGREES) {
                    // Clamp to edge of circle
                    const angleToTree = Math.atan2(treeLat - centerLat, treeLng - centerLng);
                    treeLng = centerLng + RADIUS_DEGREES * Math.cos(angleToTree);
                    treeLat = centerLat + RADIUS_DEGREES * Math.sin(angleToTree);
                }

                const treeKey = `tree_${i}`;

                treePositions.push({
                    key: treeKey,
                    lng: treeLng,
                    lat: treeLat
                });
            }

            // Track which trees should exist
            const activeTreeKeys = new Set();

            // Place trees
            for (const tree of treePositions) {
                activeTreeKeys.add(tree.key);

                // Check if tree already exists
                if (!decorativeTreeMarkers.has(tree.key)) {
                    // Validate location before placing
                    if (isValidTreeLocation(tree.lng, tree.lat)) {
                        const marker = createTreeMarker(tree.lng, tree.lat, treeEmoji);
                        decorativeTreeMarkers.set(tree.key, marker);
                    }
                }
            }

            // Remove trees that should no longer exist
            const treesToRemove = [];
            decorativeTreeMarkers.forEach((marker, treeKey) => {
                if (!activeTreeKeys.has(treeKey)) {
                    marker.remove();
                    treesToRemove.push(treeKey);
                }
            });
            treesToRemove.forEach(key => decorativeTreeMarkers.delete(key));

            console.log(`Trees on map: ${decorativeTreeMarkers.size} (${treeEmoji}) around GPS location`);
        }

        // Initialize or clear all trees (called on theme change)
        function addDecorativeTrees(themeName) {
            // Clear all existing trees
            decorativeTreeMarkers.forEach(marker => marker.remove());
            decorativeTreeMarkers.clear();
            lastTreeUpdateLocation = null; // Reset location tracker

            // Load trees for current GPS location
            updateDecorativeTrees(themeName);
        }

        // ==================== HOUSE NUMBER UTILITIES ====================

        // Convert lat/lng to tile coordinates at a given zoom level
        function latLngToTile(lat, lng, zoom) {
            const n = Math.pow(2, zoom);
            const x = Math.floor((lng + 180) / 360 * n);
            const latRad = lat * Math.PI / 180;
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            return { x, y };
        }

        // Generate cache key for a bounding box
        function getTileKeyForBounds(bounds) {
            const zoom = 17; // Use zoom 17 for tile-based caching
            const nw = latLngToTile(bounds.getNorth(), bounds.getWest(), zoom);
            const se = latLngToTile(bounds.getSouth(), bounds.getEast(), zoom);

            // Create a key that covers the bounding box
            return `${zoom}/${nw.x}-${se.x}/${nw.y}-${se.y}`;
        }

        // Debounce function to limit how often a function is called
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ==================== OVERPASS REQUEST QUEUE ====================

        // Process the Overpass API request queue
        async function processOverpassQueue() {
            if (overpassQueue.processing || overpassQueue.queue.length === 0) {
                return;
            }

            // Check if enough time has passed since last request
            const now = Date.now();
            const timeSinceLastRequest = now - overpassQueue.lastRequestTime;
            if (timeSinceLastRequest < overpassQueue.minInterval) {
                // Wait for the remaining time, then try again
                setTimeout(processOverpassQueue, overpassQueue.minInterval - timeSinceLastRequest);
                return;
            }

            // Get next request from queue
            overpassQueue.processing = true;
            const request = overpassQueue.queue.shift();

            try {
                overpassQueue.lastRequestTime = Date.now();
                await request.execute();
                overpassQueue.processing = false;

                // Process next request if any
                if (overpassQueue.queue.length > 0) {
                    setTimeout(processOverpassQueue, overpassQueue.minInterval);
                }
            } catch (error) {
                console.error('Error processing Overpass request:', error);
                overpassQueue.processing = false;

                // Retry after a longer delay on error
                if (overpassQueue.queue.length > 0) {
                    setTimeout(processOverpassQueue, overpassQueue.minInterval * 2);
                }
            }
        }

        // Add request to queue
        function enqueueOverpassRequest(execute) {
            return new Promise((resolve, reject) => {
                overpassQueue.queue.push({
                    execute: async () => {
                        try {
                            const result = await execute();
                            resolve(result);
                        } catch (error) {
                            reject(error);
                        }
                    }
                });
                processOverpassQueue();
            });
        }

        // ==================== BUILDING DATA MANAGER ====================

        // Fetch buildings with house numbers from Overpass API
        async function fetchBuildingsFromOverpass(bounds) {
            const query = `
                [out:json][timeout:25];
                (
                    way["building"]["addr:housenumber"](${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()});
                    relation["building"]["addr:housenumber"](${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()});
                );
                out center;
            `;

            // Try multiple Overpass API servers as fallbacks
            const servers = [
                'https://overpass-api.de/api/interpreter',
                'https://overpass.kumi.systems/api/interpreter',
                'https://maps.mail.ru/osm/tools/overpass/api/interpreter'
            ];

            let lastError = null;

            for (const server of servers) {
                try {
                    console.log(`Trying Overpass server: ${server}`);
                    const response = await fetch(server, {
                        method: 'POST',
                        body: query,
                        headers: { 'Content-Type': 'text/plain' }
                    });

                    if (!response.ok) {
                        lastError = new Error(`Overpass API error: ${response.status}`);
                        console.warn(`${server} returned ${response.status}, trying next server...`);
                        continue;
                    }

                    const data = await response.json();
                    console.log(`‚úì Fetched ${data.elements.length} buildings with house numbers from ${server}`);
                    return data;
                } catch (error) {
                    lastError = error;
                    console.warn(`${server} failed:`, error.message);
                    // Try next server
                }
            }

            // All servers failed
            console.error('All Overpass API servers failed');
            throw lastError || new Error('All Overpass API servers unavailable');
        }

        // Transform Overpass data to GeoJSON
        function transformOverpassToGeoJSON(overpassData) {
            const features = overpassData.elements
                .filter(el => el.tags && el.tags['addr:housenumber'])
                .slice(0, 500) // Limit to 500 buildings per viewport
                .map(el => {
                    // Get centroid coordinates
                    const lon = el.center?.lon || el.lon;
                    const lat = el.center?.lat || el.lat;

                    if (!lon || !lat) {
                        return null;
                    }

                    return {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [lon, lat]
                        },
                        properties: {
                            housenumber: el.tags['addr:housenumber'],
                            building: el.tags.building || 'yes',
                            street: el.tags['addr:street'] || null,
                            osmId: el.id
                        }
                    };
                })
                .filter(f => f !== null);

            return {
                type: 'FeatureCollection',
                features: features
            };
        }

        // Get cached buildings for a tile key
        function getCachedBuildings(tileKey) {
            const cached = buildingCache.tiles[tileKey];
            if (!cached) {
                return null;
            }

            // Check if cache is expired (10 minutes TTL)
            const now = Date.now();
            const age = now - cached.timestamp;
            if (age > 600000) { // 10 minutes
                console.log(`Cache expired for tile ${tileKey}`);
                delete buildingCache.tiles[tileKey];
                return null;
            }

            console.log(`Cache hit for tile ${tileKey} (${cached.buildings.features.length} buildings)`);
            return cached.buildings;
        }

        // Cache buildings with LRU eviction
        function cacheBuildings(tileKey, buildings) {
            // Add to cache
            buildingCache.tiles[tileKey] = {
                buildings: buildings,
                timestamp: Date.now()
            };

            // Update LRU queue
            const queueIndex = buildingCache.tileQueue.indexOf(tileKey);
            if (queueIndex > -1) {
                buildingCache.tileQueue.splice(queueIndex, 1);
            }
            buildingCache.tileQueue.push(tileKey);

            // Evict oldest tiles if cache is full
            while (buildingCache.tileQueue.length > buildingCache.maxTiles) {
                const oldestKey = buildingCache.tileQueue.shift();
                delete buildingCache.tiles[oldestKey];
                console.log(`Evicted tile ${oldestKey} from cache (LRU)`);
            }

            console.log(`Cached ${buildings.features.length} buildings for tile ${tileKey}`);
        }

        // Query buildings in current viewport
        async function queryBuildingsInViewport() {
            if (!map) return;

            const bounds = map.getBounds();
            const tileKey = getTileKeyForBounds(bounds);

            // Check cache first
            const cached = getCachedBuildings(tileKey);
            if (cached) {
                updateHouseNumberLayer(cached);
                return;
            }

            // Fetch from Overpass API
            console.log(`Fetching buildings for tile ${tileKey}...`);
            try {
                const result = await enqueueOverpassRequest(() => fetchBuildingsFromOverpass(bounds));
                const geojson = transformOverpassToGeoJSON(result);

                // Cache the results
                cacheBuildings(tileKey, geojson);

                // Update the layer
                updateHouseNumberLayer(geojson);
            } catch (error) {
                console.error('Error fetching buildings:', error.message || error);

                // Provide user-friendly feedback
                if (error.message && error.message.includes('504')) {
                    console.warn('‚ö†Ô∏è Overpass API is slow/overloaded. House numbers will retry on next pan/zoom.');
                } else if (error.message && error.message.includes('unavailable')) {
                    console.warn('‚ö†Ô∏è All Overpass API servers are currently unavailable. House numbers will retry later.');
                } else {
                    console.warn('‚ö†Ô∏è Unable to load house numbers for this area. Try panning slightly to retry.');
                }

                // Update with empty data on error (graceful degradation)
                updateHouseNumberLayer({ type: 'FeatureCollection', features: [] });
            }
        }

        // ==================== HOUSE NUMBER LAYER MANAGER ====================

        // Initialize house number layer
        function initializeHouseNumberLayer() {
            if (!map) return;

            // Add GeoJSON source
            map.addSource('house-numbers', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            // Find first symbol layer for proper stacking
            const layers = map.getStyle().layers;
            const firstSymbolLayer = layers.find(l => l.type === 'symbol');

            // Add symbol layer for house numbers
            map.addLayer({
                id: 'house-number-labels',
                type: 'symbol',
                source: 'house-numbers',
                layout: {
                    'text-field': ['get', 'housenumber'],
                    'text-size': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        17, 10,  // Smaller at zoom 17
                        18, 12,  // Medium at zoom 18
                        19, 14   // Larger at zoom 19
                    ],
                    'text-anchor': 'center',
                    'text-offset': [0, 0],
                    'text-allow-overlap': false, // Prevent label collision
                    'text-ignore-placement': false
                },
                paint: {
                    'text-color': '#ffffff',
                    'text-halo-color': '#000000',
                    'text-halo-width': 2,
                    'text-opacity': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        17, 0,     // Fade in starting at zoom 17
                        17.5, 1    // Fully visible at 17.5
                    ]
                },
                minzoom: 17
            }, firstSymbolLayer ? firstSymbolLayer.id : undefined);

            console.log('House number layer initialized');

            // Initially hide the layer
            hideHouseNumberLayer();
        }

        // Update house number layer with new data
        function updateHouseNumberLayer(geojson) {
            if (!map || !map.getSource('house-numbers')) return;

            map.getSource('house-numbers').setData(geojson);
            console.log(`Updated house number layer with ${geojson.features.length} buildings`);
        }

        // Show house number layer
        function showHouseNumberLayer() {
            if (!map || !map.getLayer('house-number-labels')) return;

            map.setLayoutProperty('house-number-labels', 'visibility', 'visible');
            houseNumbersEnabled = true;
            console.log('House numbers shown');
        }

        // Hide house number layer
        function hideHouseNumberLayer() {
            if (!map || !map.getLayer('house-number-labels')) return;

            map.setLayoutProperty('house-number-labels', 'visibility', 'none');
            houseNumbersEnabled = false;
            console.log('House numbers hidden');
        }

        // ==================== HOUSE NUMBER VISIBILITY CONTROLLER ====================

        // Check if house numbers should be visible
        function checkHouseNumberVisibility() {
            if (!map) return;

            const currentZoom = map.getZoom();
            const shouldShow = perspectiveMode && currentZoom >= 17;

            if (shouldShow && !houseNumbersEnabled) {
                // Show house numbers and fetch data
                showHouseNumberLayer();
                updateHouseNumbersIfNeeded();
            } else if (!shouldShow && houseNumbersEnabled) {
                // Hide house numbers
                hideHouseNumberLayer();
            }
        }

        // Debounced viewport update function
        const updateHouseNumbersIfNeeded = debounce(() => {
            if (perspectiveMode && map && map.getZoom() >= 17) {
                queryBuildingsInViewport();
            }
        }, VIEWPORT_UPDATE_DEBOUNCE);

        // ==================== DISPLAY UPDATES ====================
        // Auto-zoom state tracking
        let autoZoomState = {
            isZoomedOut: false,  // Track if we're currently in the zoomed-out state
            lastSpeed: 0
        };

        function handleAutoZoom(speedMph) {
            // Convert speedMph to number (it might be '--' string)
            const speed = speedMph === '--' ? 0 : parseFloat(speedMph);

            if (!map) return;

            const SPEED_THRESHOLD = 55;  // MPH
            const HIGH_SPEED_ZOOM = 18;
            const NORMAL_ZOOM = 17;
            const ANIMATION_DURATION = 3;  // seconds

            // Check if we need to zoom out (going fast)
            if (speed > SPEED_THRESHOLD && !autoZoomState.isZoomedOut) {
                // Speed exceeded threshold - zoom out to 18
                map.setZoom(HIGH_SPEED_ZOOM, {
                    animate: true,
                    duration: ANIMATION_DURATION
                });
                autoZoomState.isZoomedOut = true;
                console.log(`Speed ${speed} mph > ${SPEED_THRESHOLD} mph - zooming out to ${HIGH_SPEED_ZOOM}`);
            }
            // Check if we need to zoom back in (slowed down)
            else if (speed <= SPEED_THRESHOLD && autoZoomState.isZoomedOut) {
                // Speed dropped below threshold - zoom back in to 17
                map.setZoom(NORMAL_ZOOM, {
                    animate: true,
                    duration: ANIMATION_DURATION
                });
                autoZoomState.isZoomedOut = false;
                console.log(`Speed ${speed} mph <= ${SPEED_THRESHOLD} mph - zooming in to ${NORMAL_ZOOM}`);
            }

            autoZoomState.lastSpeed = speed;
        }

        function updateDisplay() {
            if (!currentLocation) return;

            // Speed (convert m/s to mph)
            const speedMph = currentLocation.speed !== null ?
                (currentLocation.speed * 2.237).toFixed(0) : '--';
            document.getElementById('speed').textContent = speedMph;

            // Speed limit
            if (roadInfo && roadInfo.speedLimit) {
                const speedElement = document.getElementById('speed-limit');
                const currentSpeed = currentLocation.speed !== null ?
                    (currentLocation.speed * 2.237) : 0;

                // Add visual indicator if showing cached data
                const cachedIndicator = speedLimitCache.isCached ?
                    ' <span style="opacity: 0.6; font-size: 0.85em;">(cached)</span>' : '';

                // Color code based on current speed vs limit
                if (currentSpeed > roadInfo.speedLimit + 5) {
                    // Over speed limit by 5+ mph - orange warning
                    speedElement.innerHTML = `Limit <span style="color: #f97316;">${roadInfo.speedLimit}</span> mph${cachedIndicator}`;
                } else {
                    // Within speed limit - normal gray
                    speedElement.innerHTML = `Limit ${roadInfo.speedLimit} mph${cachedIndicator}`;
                }
            } else {
                document.getElementById('speed-limit').textContent = '--';
            }

            // Auto-zoom based on speed
            handleAutoZoom(speedMph);

            // Heading
            let heading = currentLocation.heading;

            // Calculate heading from movement if GPS heading not available
            if ((heading === null || heading === undefined) && previousLocation && currentLocation.speed > 1) {
                heading = calculateBearing(
                    previousLocation.lat,
                    previousLocation.lng,
                    currentLocation.lat,
                    currentLocation.lng
                );
            }

            if (heading !== null && heading !== undefined) {
                document.getElementById('heading').textContent = heading.toFixed(0);
                document.getElementById('direction').textContent = getCardinalDirection(heading);

                // Rotate arrow to point in heading direction
                const arrowElement = document.getElementById('heading-arrow');
                arrowElement.style.transform = `rotate(${heading}deg)`;
                arrowElement.style.opacity = '1';
            } else {
                document.getElementById('heading').textContent = '--';
                document.getElementById('direction').textContent = 'Stationary';

                // Dim arrow when stationary
                const arrowElement = document.getElementById('heading-arrow');
                arrowElement.style.opacity = '0.3';
            }

            // Update compass based on map bearing (camera direction)
            // Compass arrow always points to north, so rotate opposite to map bearing
            const mapBearing = map.getBearing();
            const compassArrow = document.getElementById('compass-arrow');
            compassArrow.style.transform = `rotate(${-mapBearing}deg)`;

            // Accuracy (convert meters to feet) - inline in header
            const accuracyFt = (currentLocation.accuracy * 3.28084).toFixed(0);
            document.getElementById('accuracy-inline').textContent = `¬±${accuracyFt}ft`;

            // Altitude (convert meters to feet)
            if (currentLocation.altitude !== null) {
                const altitudeFt = (currentLocation.altitude * 3.28084).toFixed(0);
                document.getElementById('altitude').textContent = altitudeFt;
            } else {
                document.getElementById('altitude').textContent = '--';
            }

            // Coordinates - bottom left of map
            document.getElementById('map-coordinates').textContent =
                `${currentLocation.lat.toFixed(6)}, ${currentLocation.lng.toFixed(6)}`;

            // Road info
            if (roadInfo) {
                // ALWAYS show highway number if we have it, optionally add name in parentheses
                let roadName;

                if (roadInfo.highwayNumber) {
                    // Format the highway number (I25, US287, FM2499, etc.)
                    const formattedNumber = formatHighwayName(roadInfo.highwayNumber);

                    if (roadInfo.roadName) {
                        // Have both number and name: "I35E (Ronald Reagan Highway)"
                        roadName = `${formattedNumber} (${roadInfo.roadName})`;
                    } else {
                        // Just the number: "I35E", "FM2499"
                        roadName = formattedNumber;
                    }
                } else if (roadInfo.road) {
                    // No highway number, just show whatever road info we have
                    roadName = formatHighwayName(roadInfo.road);
                } else {
                    roadName = 'Unknown';
                }

                document.getElementById('road-name').textContent = roadName;
                document.getElementById('road-type').textContent =
                    `${roadInfo.type} ‚Ä¢ ${roadInfo.city}, ${roadInfo.state}`;
            }

            // Update weather display (for dynamic sunrise/sunset transitions)
            updateWeatherDisplay();
        }

        // ==================== RAIN ANIMATION ====================

        // Check if weather code indicates rain/precipitation
        function isRainingWeatherCode(code) {
            // Rain codes: drizzle (51,53,55), rain (61,63,65), showers (80,81,82), thunderstorms (95,96,99)
            const rainCodes = [51, 53, 55, 61, 63, 65, 80, 81, 82, 95, 96, 99];
            return rainCodes.includes(code);
        }

        // Create raindrop elements with random positions and animation delays
        function createRaindrops() {
            const rainOverlay = document.getElementById('rain-overlay');
            const dropCount = 75; // Number of raindrops

            for (let i = 0; i < dropCount; i++) {
                const drop = document.createElement('div');
                drop.className = 'raindrop';

                // Random horizontal position (0-100%)
                const leftPos = Math.random() * 100;
                drop.style.left = `${leftPos}%`;

                // Random animation duration (0.5-1.5 seconds)
                const duration = 0.5 + Math.random();
                drop.style.animationDuration = `${duration}s`;

                // Random animation delay (0-2 seconds for staggered effect)
                const delay = Math.random() * 2;
                drop.style.animationDelay = `${delay}s`;

                rainOverlay.appendChild(drop);
            }
        }

        // Show rain animation
        function showRain() {
            const rainOverlay = document.getElementById('rain-overlay');
            console.log('showRain called, rainOverlay found:', !!rainOverlay);

            if (!rainOverlay) {
                console.error('rain-overlay element not found!');
                return;
            }

            // Only show if not already active
            if (!rainOverlay.classList.contains('active')) {
                rainOverlay.classList.add('active');
                createRaindrops();
                console.log('Rain animation started - droplets created');
            } else {
                console.log('Rain animation already active');
            }
        }

        // Hide rain animation
        function hideRain() {
            const rainOverlay = document.getElementById('rain-overlay');

            if (rainOverlay.classList.contains('active')) {
                rainOverlay.classList.remove('active');
                // Clear all raindrops
                rainOverlay.innerHTML = '';
                console.log('Rain animation stopped');
            }
        }

        // Update rain animation based on radar visibility and weather data (simplified detection)
        function updateRainAnimation(weatherCode, precipitation) {
            console.log('Rain detection - Code:', weatherCode, 'Precip:', precipitation);

            // Show rain only if weather API confirms rain at GPS location
            const apiConfirmsRain = (typeof weatherCode === 'number' && isRainingWeatherCode(weatherCode)) ||
                                    (precipitation !== null && precipitation !== undefined && precipitation > 0);

            console.log('Rain signals - apiConfirmsRain:', apiConfirmsRain);

            if (apiConfirmsRain) {
                showRain();
            } else {
                hideRain();
            }
        }

        function updateExitsDisplay() {
            const exitsList = document.getElementById('exits-list');

            if (nearbyExits.length === 0) {
                exitsList.innerHTML = '<div class="no-data">No exits within 0.5 miles</div>';

                // Clear markers
                exitMarkers.forEach(marker => marker.remove());
                exitMarkers = [];
                return;
            }

            // Separate exits from entrances
            const exits = nearbyExits.filter(e => e.type === 'exit');
            const entrances = nearbyExits.filter(e => e.type === 'entrance');

            // Display exits
            let html = '';

            if (exits.length > 0) {
                html += '<div style="margin-bottom: 8px; font-size: 11px; color: #f97316; font-weight: 600;">EXITS</div>';
                html += exits.map(exit => `
                    <div class="exit-item">
                        <div class="exit-name" style="color: #f97316;">üî¥ ${exit.name}</div>
                        <div class="exit-meta">
                            <span>üìç ${exit.distance.toFixed(2)} mi</span>
                            ${exit.destination ? `<span>‚Üí ${exit.destination}</span>` : ''}
                        </div>
                    </div>
                `).join('');
            }

            if (entrances.length > 0) {
                if (exits.length > 0) html += '<div style="margin: 12px 0; border-top: 1px solid #3a3a3a;"></div>';
                html += '<div style="margin-bottom: 8px; font-size: 11px; color: #10b981; font-weight: 600;">ENTRANCES</div>';
                html += entrances.map(entrance => `
                    <div class="exit-item">
                        <div class="exit-name" style="color: #10b981;">üü¢ ${entrance.name}</div>
                        <div class="exit-meta">
                            <span>üìç ${entrance.distance.toFixed(2)} mi</span>
                            ${entrance.destination ? `<span>‚Üí ${entrance.destination}</span>` : ''}
                        </div>
                    </div>
                `).join('');
            }

            exitsList.innerHTML = html;

            // Update map markers
            exitMarkers.forEach(marker => marker.remove());
            exitMarkers = [];

            nearbyExits.slice(0, 5).forEach(exit => {
                // Different colors for exits vs entrances
                const isExit = exit.type === 'exit';
                const color = isExit ? '#f97316' : '#10b981';  // Orange for exits, green for entrances
                const label = isExit ? 'Exit' : 'Entrance';

                // Create custom marker element for MapLibre
                const exitEl = document.createElement('div');
                exitEl.className = 'exit-marker';
                exitEl.style.width = '12px';
                exitEl.style.height = '12px';
                exitEl.style.borderRadius = '50%';
                exitEl.style.backgroundColor = color;
                exitEl.style.border = '2px solid #ffffff';
                exitEl.style.boxShadow = '0 0 4px rgba(0,0,0,0.3)';
                exitEl.style.cursor = 'pointer';

                const marker = new maplibregl.Marker({
                    element: exitEl,
                    anchor: 'center'
                })
                .setLngLat([exit.lng, exit.lat]) // [lng, lat] - REVERSED!
                .setPopup(
                    new maplibregl.Popup({offset: 15})
                    .setHTML(`<strong>${label}: ${exit.name}</strong><br>${exit.distance.toFixed(2)} mi`)
                )
                .addTo(map);

                exitMarkers.push(marker);
            });
        }

        // ==================== STYLE CUSTOMIZATION ====================
        function toggleStyleEditor() {
            const content = document.getElementById('style-editor-content');
            const toggle = document.getElementById('style-editor-toggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }

        function toggleExits() {
            const content = document.getElementById('exits-content');
            const toggle = document.getElementById('exits-toggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñ≤';
                localStorage.setItem('exits-collapsed', 'false');
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñº';
                localStorage.setItem('exits-collapsed', 'true');
            }
        }

        // Helper: Convert hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Helper: Convert RGB to hex
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // Helper: Determine if color is light or dark
        function isLightColor(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return false;
            // Calculate luminance using relative luminance formula
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            return luminance > 0.5;
        }

        // Helper: Generate gradient color (darker if light, lighter if dark)
        function generateGradientColor(baseColor, amount = 0.7) {
            const rgb = hexToRgb(baseColor);
            if (!rgb) return baseColor;

            const isLight = isLightColor(baseColor);
            const factor = isLight ? (1 - amount) : (1 + amount);

            let r = Math.round(rgb.r * factor);
            let g = Math.round(rgb.g * factor);
            let b = Math.round(rgb.b * factor);

            // Clamp values to 0-255
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            return rgbToHex(r, g, b);
        }

        // Helper: Apply color (no gradient for now)
        function createGradientExpression(baseColor, gradientColor) {
            // Just use the base color - no gradient
            return baseColor;
        }

        async function fetchAndCustomizeStyle(baseStyleURL, customColors) {
            try {
                const response = await fetch(baseStyleURL);
                const styleJSON = await response.json();

                // Generate gradient colors
                const highwayGradient = generateGradientColor(customColors.highway);
                const primaryGradient = generateGradientColor(customColors.primary);
                const streetGradient = generateGradientColor(customColors.street);
                const waterGradient = generateGradientColor(customColors.water);
                const waterwayGradient = generateGradientColor(customColors.waterway);
                const parkGradient = generateGradientColor(customColors.park);
                const backgroundGradient = generateGradientColor(customColors.background);

                console.log('Applying custom colors with gradients:', {
                    highway: customColors.highway + ' -> ' + highwayGradient,
                    primary: customColors.primary + ' -> ' + primaryGradient,
                    street: customColors.street + ' -> ' + streetGradient,
                    water: customColors.water + ' -> ' + waterGradient,
                    park: customColors.park + ' -> ' + parkGradient
                });

                let modifiedLayers = [];

                // Find and modify layers
                styleJSON.layers.forEach(layer => {
                    if (!layer.paint) return;

                    // Modify highway colors with gradient
                    if (layer.id.includes('road_mot') || layer.id.includes('motorway')) {
                        if (layer.paint['line-color']) {
                            const oldColor = layer.paint['line-color'];
                            layer.paint['line-color'] = createGradientExpression(customColors.highway, highwayGradient);
                            modifiedLayers.push(layer.id + ' (highway): ' + JSON.stringify(oldColor).substring(0, 50) + ' -> gradient');
                        }
                    }

                    // Modify primary road colors with gradient
                    if (layer.id.includes('road_pri') || layer.id.includes('primary')) {
                        if (layer.paint['line-color']) {
                            layer.paint['line-color'] = createGradientExpression(customColors.primary, primaryGradient);
                            modifiedLayers.push(layer.id + ' (primary)');
                        }
                    }

                    // Modify street colors with gradient (secondary, tertiary, residential roads)
                    if (layer.id.includes('road_sec') || layer.id.includes('secondary') ||
                        layer.id.includes('road_ter') || layer.id.includes('tertiary') ||
                        layer.id.includes('road_res') || layer.id.includes('residential') ||
                        layer.id.includes('road_min') || layer.id.includes('minor')) {
                        if (layer.paint['line-color']) {
                            layer.paint['line-color'] = createGradientExpression(customColors.street, streetGradient);
                            modifiedLayers.push(layer.id + ' (street)');
                        }
                    }

                    // Modify building colors (no gradient)
                    if (layer.id === 'building' || layer.id === 'building-top') {
                        if (layer.paint['fill-color']) {
                            layer.paint['fill-color'] = customColors.building;
                            modifiedLayers.push(layer.id + ' (building)');
                        }
                    }

                    // Modify water colors with gradient
                    if (layer.id === 'water') {
                        if (layer.paint['fill-color']) {
                            layer.paint['fill-color'] = createGradientExpression(customColors.water, waterGradient);
                            modifiedLayers.push(layer.id + ' (water)');
                        }
                    }

                    // Modify waterway colors with gradient
                    if (layer.id === 'waterway') {
                        if (layer.paint['line-color']) {
                            layer.paint['line-color'] = createGradientExpression(customColors.waterway, waterwayGradient);
                            modifiedLayers.push(layer.id + ' (waterway)');
                        }
                    }

                    // Modify park colors with gradient (parks, forests, green spaces)
                    if (layer.id.includes('park') || layer.id.includes('wood') ||
                        layer.id.includes('forest') || layer.id.includes('nature') ||
                        layer.id.includes('grass') || layer.id.includes('recreation')) {
                        if (layer.paint['fill-color']) {
                            layer.paint['fill-color'] = createGradientExpression(customColors.park, parkGradient);
                            modifiedLayers.push(layer.id + ' (park)');
                        }
                    }

                    // Modify background color with gradient (land)
                    if (layer.id === 'background' || layer.id === 'landcover' ||
                        layer.id === 'land' || layer.id.includes('landuse')) {
                        if (layer.paint['background-color']) {
                            layer.paint['background-color'] = createGradientExpression(customColors.background, backgroundGradient);
                            modifiedLayers.push(layer.id + ' (background-color)');
                        }
                        if (layer.paint['fill-color']) {
                            layer.paint['fill-color'] = createGradientExpression(customColors.background, backgroundGradient);
                            modifiedLayers.push(layer.id + ' (background-fill)');
                        }
                    }

                    // Modify text/label colors and size
                    if (layer.type === 'symbol') {
                        // Update text color
                        if (layer.paint && layer.paint['text-color']) {
                            layer.paint['text-color'] = customColors.text;
                        }
                        if (layer.paint && layer.paint['text-halo-color']) {
                            // Keep halo but adjust to contrast with new text color
                            layer.paint['text-halo-color'] = customColors.text === '#333333' ? '#FFFFFF' : '#000000';
                        }

                        // Update text size - recursively scale ALL text size values
                        if (layer.layout && customColors.textSize) {
                            const scaleFactor = customColors.textSize / 12;

                            // Recursive function to scale text sizes in nested expressions
                            const scaleTextSizeRecursive = (value, context = null) => {
                                // Handle simple number
                                if (typeof value === 'number') {
                                    // Only scale if it looks like a font size (6-100) and we're not in a zoom context
                                    if (context !== 'zoom' && value >= 6 && value <= 100) {
                                        return value * scaleFactor;
                                    }
                                    return value;
                                }

                                // Handle arrays
                                if (Array.isArray(value)) {
                                    // Check if this is an interpolate expression: ["interpolate", [...], ["zoom"], val1, val2, ...]
                                    if (value[0] === 'interpolate' && Array.isArray(value[2]) && value[2][0] === 'zoom') {
                                        // Scale only the odd-indexed values after position 3 (the size values, not zoom levels)
                                        return value.map((item, index) => {
                                            // Values at indices 4, 6, 8, 10... are sizes (odd positions after header)
                                            if (index > 3 && index % 2 === 0) {
                                                return scaleTextSizeRecursive(item, 'size');
                                            }
                                            return scaleTextSizeRecursive(item, index > 3 && index % 2 === 1 ? 'zoom' : null);
                                        });
                                    }
                                    // Regular array - recurse normally
                                    return value.map(item => scaleTextSizeRecursive(item, context));
                                }

                                // Handle objects
                                if (typeof value === 'object' && value !== null) {
                                    // Handle "stops" format: { "stops": [[zoom, size], [zoom, size]] }
                                    if (value.stops && Array.isArray(value.stops)) {
                                        return {
                                            ...value,
                                            stops: value.stops.map(stop => {
                                                if (Array.isArray(stop) && stop.length === 2) {
                                                    // stop[0] is zoom (don't scale), stop[1] is size (scale it)
                                                    return [stop[0], scaleTextSizeRecursive(stop[1], 'size')];
                                                }
                                                return stop;
                                            })
                                        };
                                    }
                                    // Regular object - recurse
                                    const scaled = {};
                                    for (const key in value) {
                                        scaled[key] = scaleTextSizeRecursive(value[key], context);
                                    }
                                    return scaled;
                                }

                                return value;
                            };

                            // Apply to text-size
                            if (layer.layout['text-size']) {
                                layer.layout['text-size'] = scaleTextSizeRecursive(layer.layout['text-size']);
                            }
                        }

                        // Force all text to be horizontal (not rotated along roads)
                        if (layer.layout) {
                            layer.layout['text-rotation-alignment'] = 'viewport';
                            layer.layout['text-pitch-alignment'] = 'viewport';
                        }
                    }
                });

                console.log('Modified layers:', modifiedLayers);
                console.log('Total layers modified:', modifiedLayers.length);

                return styleJSON;
            } catch (error) {
                console.error('Style fetch error:', error);
                throw error;
            }
        }

        async function applyCustomStyle() {
            const customColors = {
                highway: document.getElementById('color-highway').value,
                primary: document.getElementById('color-primary').value,
                street: document.getElementById('color-street').value,
                building: document.getElementById('color-building').value,
                water: document.getElementById('color-water').value,
                waterway: document.getElementById('color-waterway').value,
                park: document.getElementById('color-park').value,
                background: document.getElementById('color-background').value,
                text: document.getElementById('color-text').value,
                textSize: parseInt(document.getElementById('text-size-slider').value),
                markerFill: document.getElementById('color-marker').value,
                markerBorder: document.getElementById('color-marker-border').value
            };

            const currentStyle = localStorage.getItem('map_style') || 'voyager';
            const baseStyleURL = getVectorStyleURL(currentStyle);

            try {
                const customStyleJSON = await fetchAndCustomizeStyle(baseStyleURL, customColors);
                map.setStyle(customStyleJSON);

                map.once('styledata', () => {
                    loadRadar();
                });

                // Apply marker colors
                applyMarkerColors(customColors.markerFill, customColors.markerBorder);

                console.log('Custom style applied');
            } catch (error) {
                alert('Failed to apply custom style');
            }
        }

        function saveCustomStyle() {
            const customColors = {
                highway: document.getElementById('color-highway').value,
                primary: document.getElementById('color-primary').value,
                street: document.getElementById('color-street').value,
                building: document.getElementById('color-building').value,
                water: document.getElementById('color-water').value,
                waterway: document.getElementById('color-waterway').value,
                park: document.getElementById('color-park').value,
                background: document.getElementById('color-background').value,
                text: document.getElementById('color-text').value,
                textSize: document.getElementById('text-size-slider').value,
                markerFill: document.getElementById('color-marker').value,
                markerBorder: document.getElementById('color-marker-border').value
            };

            localStorage.setItem('custom_style_colors', JSON.stringify(customColors));
            alert('Custom colors saved!');
        }

        function resetStyle() {
            // Reset to defaults
            document.getElementById('color-highway').value = '#FFA500';
            document.getElementById('color-primary').value = '#FFDD88';
            document.getElementById('color-street').value = '#FFFFFF';
            document.getElementById('color-building').value = '#E4DCD0';
            document.getElementById('color-water').value = '#B0D0D6';
            document.getElementById('color-waterway').value = '#CCE7EA';
            document.getElementById('color-park').value = '#C8E6C9';
            document.getElementById('color-background').value = '#F5F5F0';
            document.getElementById('color-text').value = '#333333';
            document.getElementById('text-size-slider').value = '12';
            document.getElementById('text-size-value').textContent = '12px';
            document.getElementById('color-marker').value = '#4285F4';
            document.getElementById('color-marker-border').value = '#FFFFFF';

            // Reload base style
            const currentStyle = localStorage.getItem('map_style') || 'voyager';
            map.setStyle(getVectorStyleURL(currentStyle));

            map.once('styledata', () => {
                loadRadar();
            });

            // Reset marker colors
            applyMarkerColors('#4285F4', '#FFFFFF');
        }

        // Load saved custom colors on init
        function loadSavedColors() {
            const saved = localStorage.getItem('custom_style_colors');
            if (saved) {
                const colors = JSON.parse(saved);
                document.getElementById('color-highway').value = colors.highway || '#FFA500';
                document.getElementById('color-primary').value = colors.primary || '#FFDD88';
                document.getElementById('color-street').value = colors.street || '#FFFFFF';
                document.getElementById('color-building').value = colors.building || '#E4DCD0';
                document.getElementById('color-water').value = colors.water || '#B0D0D6';
                document.getElementById('color-waterway').value = colors.waterway || '#CCE7EA';
                document.getElementById('color-park').value = colors.park || '#C8E6C9';
                document.getElementById('color-background').value = colors.background || '#F5F5F0';
                document.getElementById('color-text').value = colors.text || '#333333';

                const textSize = colors.textSize || '12';
                document.getElementById('text-size-slider').value = textSize;
                document.getElementById('text-size-value').textContent = textSize + 'px';

                // Load marker colors
                if (colors.markerFill) {
                    markerFillColor = colors.markerFill;
                    document.getElementById('color-marker').value = colors.markerFill;
                }
                if (colors.markerBorder) {
                    markerBorderColor = colors.markerBorder;
                    document.getElementById('color-marker-border').value = colors.markerBorder;
                }
            }
        }

        // ==================== UTILITIES ====================
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 3959; // Earth radius in miles
            const dLat = toRad(lat2 - lat1);
            const dLng = toRad(lng2 - lng1);

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLng / 2) * Math.sin(dLng / 2);

            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLng = toRad(lng2 - lng1);
            const y = Math.sin(dLng) * Math.cos(toRad(lat2));
            const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                      Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLng);
            const bearing = Math.atan2(y, x);
            return (toDeg(bearing) + 360) % 360;
        }

        function toRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        function toDeg(radians) {
            return radians * (180 / Math.PI);
        }

        function getCardinalDirection(heading) {
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const index = Math.round(((heading % 360) / 45)) % 8;
            return directions[index];
        }

        function updateStatus(text, state) {
            document.getElementById('status-text').textContent = text;
            const dot = document.getElementById('status-dot');
            dot.className = 'status-indicator ' + state;
        }
    </script>
</body>
</html>
