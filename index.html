<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Road Trip Telemetry</title>

    <!-- MapLibre GL JS CSS -->
    <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e5e5e5;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            color: white;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .header .subtitle {
            font-size: 14px;
            opacity: 0.9;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 15px;
            gap: 15px;
        }

        /* Telemetry Cards */
        .telemetry-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .telemetry-card {
            background: #2d2d2d;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .telemetry-card.full-width {
            grid-column: 1 / -1;
        }

        .telemetry-label {
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .telemetry-value {
            font-size: 28px;
            font-weight: 700;
            color: #f97316;
            line-height: 1;
        }

        .telemetry-value.large {
            font-size: 36px;
        }

        .telemetry-unit {
            font-size: 16px;
            color: #666;
            margin-left: 4px;
        }

        .telemetry-secondary {
            font-size: 14px;
            color: #999;
            margin-top: 8px;
        }

        /* Heading Arrow */
        .heading-arrow {
            display: inline-block;
            width: 40px;
            height: 40px;
            margin-left: 12px;
            vertical-align: middle;
            transition: transform 0.5s ease-out, opacity 0.3s ease;
        }

        .heading-arrow svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        /* Wind Arrow */
        .wind-arrow {
            display: inline-block;
            width: 40px;
            height: 40px;
            margin-left: 12px;
            vertical-align: middle;
            transition: transform 0.5s ease-out, opacity 0.3s ease;
        }

        .wind-arrow svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        /* Map Section */
        .map-section {
            position: relative;
            background: #2d2d2d;
            border-radius: 12px;
            overflow: hidden;
            height: 250px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Exits List */
        .exits-section {
            background: #2d2d2d;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .exits-header {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #f97316;
        }

        .exit-item {
            background: #3a3a3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .exit-item:last-child {
            margin-bottom: 0;
        }

        .exit-name {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .exit-meta {
            font-size: 12px;
            color: #999;
            display: flex;
            gap: 12px;
        }

        .no-data {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 14px;
        }

        /* Status Indicator */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .status-indicator.active {
            background: #10b981;
            box-shadow: 0 0 8px #10b981;
            animation: pulse 2s infinite;
        }

        .status-indicator.waiting {
            background: #f59e0b;
        }

        .status-indicator.error {
            background: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Search Box */
        .search-box {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            background: #2d2d2d;
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            padding: 10px 15px;
            color: #666;
            font-size: 14px;
            cursor: not-allowed;
        }

        .search-box::placeholder {
            color: #666;
            opacity: 1;
        }

        .search-box:disabled {
            background: #2d2d2d;
            color: #666;
        }

        /* Coordinates Display */
        .map-coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(45, 45, 45, 0.7);
            border-radius: 4px;
            padding: 4px 8px;
            color: #888;
            font-size: 10px;
            font-family: monospace;
            pointer-events: none;
        }

        /* Range Slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #4a4a4a;
            border-radius: 4px;
            outline: none;
            padding: 8px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 32px;
            height: 32px;
            background: #f97316;
            border: 7px solid transparent;
            border-radius: 50%;
            background-clip: padding-box;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.1);
            box-shadow: 0 0 0 8px rgba(249, 115, 22, 0.15);
        }

        input[type="range"]::-moz-range-thumb {
            width: 32px;
            height: 32px;
            background: #f97316;
            border: 7px solid transparent;
            border-radius: 50%;
            background-clip: padding-box;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        input[type="range"]::-moz-range-thumb:active {
            transform: scale(1.1);
            box-shadow: 0 0 0 8px rgba(249, 115, 22, 0.15);
        }

        /* Landscape Layout */
        @media (min-width: 768px) and (orientation: landscape) {
            .main-content {
                flex-direction: row;
            }

            .left-panel {
                flex: 1;
                overflow-y: auto;
            }

            .right-panel {
                flex: 2;
                display: flex;
                flex-direction: column;
                gap: 15px;
            }

            .map-section {
                flex: 1;
                height: auto;
            }
        }

        /* Login Screen */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .login-overlay.hidden {
            display: none;
        }

        .login-box {
            background: #2d2d2d;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            max-width: 400px;
            width: 90%;
        }

        .login-box h2 {
            color: #f97316;
            font-size: 28px;
            margin-bottom: 10px;
            text-align: center;
        }

        .login-box p {
            color: #999;
            font-size: 14px;
            text-align: center;
            margin-bottom: 30px;
        }

        .login-input {
            width: 100%;
            padding: 15px;
            background: #3a3a3a;
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            color: #e5e5e5;
            font-size: 16px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }

        .login-input:focus {
            outline: none;
            border-color: #f97316;
        }

        .login-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .login-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(249, 115, 22, 0.4);
        }

        .login-button:active {
            transform: translateY(0);
        }

        .login-error {
            color: #ef4444;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
            display: none;
        }

        .login-error.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div class="login-overlay" id="login-overlay">
        <div class="login-box">
            <h2>ðŸ”’ Access Required</h2>
            <p>Enter password to view telemetry</p>
            <form id="login-form" onsubmit="return false;">
                <input
                    type="password"
                    class="login-input"
                    id="password-input"
                    placeholder="Enter password"
                    autocomplete="off"
                    autofocus
                >
                <button type="submit" class="login-button" id="login-button">Unlock</button>
                <div class="login-error" id="login-error">Incorrect password</div>
            </form>
        </div>
    </div>

    <div class="container">
        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Panel: Telemetry -->
            <div class="left-panel">
                <!-- GPS Status -->
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; padding: 8px 12px; background: rgba(45, 45, 45, 0.5); border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="status-indicator waiting" id="status-dot"></span>
                        <span id="status-text" style="font-size: 13px;">Initializing GPS...</span>
                    </div>
                    <span id="accuracy-inline" style="font-size: 12px; opacity: 0.8;">--</span>
                </div>

                <!-- Current Road/Highway -->
                <div class="telemetry-card full-width" style="margin-bottom: 12px;">
                    <div class="telemetry-label">Current Road</div>
                    <div class="telemetry-value" style="font-size: 20px;" id="road-name">Detecting...</div>
                    <div class="telemetry-secondary" id="road-type">--</div>
                </div>

                <!-- Speed, Heading, Altitude Row -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 12px;">
                    <!-- Speed -->
                    <div class="telemetry-card">
                        <div class="telemetry-label">Speed</div>
                        <div class="telemetry-value large">
                            <span id="speed">--</span>
                            <span class="telemetry-unit">mph</span>
                        </div>
                        <div class="telemetry-secondary" id="speed-limit">--</div>
                    </div>

                    <!-- Heading -->
                    <div class="telemetry-card">
                        <div class="telemetry-label">Heading</div>
                        <div class="telemetry-value">
                            <span id="heading">--</span>
                            <span class="telemetry-unit">Â°</span>
                            <span class="heading-arrow" id="heading-arrow">
                                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 2L12 22M12 2L6 8M12 2L18 8" stroke="#f97316" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                                    <circle cx="12" cy="12" r="1.5" fill="#f97316"/>
                                </svg>
                            </span>
                        </div>
                        <div class="telemetry-secondary" id="direction">--</div>
                    </div>

                    <!-- Altitude -->
                    <div class="telemetry-card">
                        <div class="telemetry-label">Altitude</div>
                        <div class="telemetry-value">
                            <span id="altitude">--</span>
                            <span class="telemetry-unit">ft</span>
                        </div>
                    </div>
                </div>

                <!-- Upcoming Exits -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Nearby Exits (0.5 mi ahead)</div>
                    <div id="exits-list">
                        <div class="no-data">No exits nearby</div>
                    </div>
                </div>

                <!-- Weather Section -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Current Weather</div>
                    <div class="telemetry-grid" style="margin-top: 12px;">
                        <!-- Temperature -->
                        <div class="telemetry-card">
                            <div class="telemetry-label">Temperature</div>
                            <div class="telemetry-value">
                                <span id="weather-temp">--</span>
                                <span class="telemetry-unit">Â°F</span>
                            </div>
                        </div>

                        <!-- Feels Like -->
                        <div class="telemetry-card">
                            <div class="telemetry-label">Feels Like</div>
                            <div class="telemetry-value">
                                <span id="weather-feels">--</span>
                                <span class="telemetry-unit">Â°F</span>
                            </div>
                        </div>

                        <!-- Humidity -->
                        <div class="telemetry-card">
                            <div class="telemetry-label">Humidity</div>
                            <div class="telemetry-value">
                                <span id="weather-humidity">--</span>
                                <span class="telemetry-unit">%</span>
                            </div>
                        </div>

                        <!-- Wind -->
                        <div class="telemetry-card">
                            <div class="telemetry-label">Wind</div>
                            <div class="telemetry-value" style="font-size: 20px;">
                                <span id="weather-wind">--</span>
                                <span class="telemetry-unit">mph</span>
                                <span class="wind-arrow" id="wind-arrow">
                                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 2L12 22M12 2L6 8M12 2L18 8" stroke="#f97316" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                                        <circle cx="12" cy="12" r="1.5" fill="#f97316"/>
                                    </svg>
                                </span>
                            </div>
                            <div class="telemetry-secondary">
                                <span id="weather-wind-gust">--</span> â€¢ <span id="weather-wind-dir">--</span>
                            </div>
                        </div>

                        <!-- Condition -->
                        <div class="telemetry-card full-width">
                            <div class="telemetry-label">Condition</div>
                            <div class="telemetry-value" style="font-size: 20px;" id="weather-condition">Loading...</div>
                        </div>

                        <!-- Sunrise/Sunset -->
                        <div class="telemetry-card full-width">
                            <div class="telemetry-label" id="sun-label">--</div>
                            <div class="telemetry-value" style="font-size: 20px;" id="sun-time">--</div>
                        </div>
                    </div>
                </div>

                <!-- Radar Opacity Control -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Radar Opacity</div>
                    <div style="padding: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button id="opacity-decrease" style="width: 32px; height: 32px; border: none; background: #2a2a2a; color: #f97316; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">âˆ’</button>
                            <input type="range" id="radar-opacity-slider" min="0" max="100" value="60" style="flex: 1;">
                            <button id="opacity-increase" style="width: 32px; height: 32px; border: none; background: #2a2a2a; color: #f97316; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">+</button>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 11px; color: #666;">
                            <span>0%</span>
                            <span id="radar-opacity-value">60%</span>
                            <span>100%</span>
                        </div>
                    </div>
                </div>

                <!-- Map Zoom Control -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Map Zoom</div>
                    <div style="padding: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button id="zoom-decrease" style="width: 32px; height: 32px; border: none; background: #2a2a2a; color: #f97316; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">âˆ’</button>
                            <input type="range" id="map-zoom-slider" min="8" max="19" value="18" style="flex: 1;">
                            <button id="zoom-increase" style="width: 32px; height: 32px; border: none; background: #2a2a2a; color: #f97316; border-radius: 4px; cursor: pointer; font-size: 18px; font-weight: bold;">+</button>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 11px; color: #666;">
                            <span>8</span>
                            <span id="map-zoom-value">18</span>
                            <span>19</span>
                        </div>
                    </div>
                </div>

                <!-- Map Style Selector -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header">Map Style</div>
                    <div style="padding: 12px;">
                        <select id="map-style-selector" style="width: 100%; padding: 8px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #444; border-radius: 4px; cursor: pointer; font-size: 13px;">
                            <option value="voyager">CARTO Voyager (Default)</option>
                            <option value="dark">CARTO Dark Matter</option>
                            <option value="satellite">Esri Satellite</option>
                            <option value="executive-light">Executive Lightmode</option>
                            <option value="executive-dark">Executive Darkmode</option>
                            <option value="cartoon-light">Cartoon Lightmode</option>
                            <option value="cartoon-dark">Cartoon Darkmode</option>
                            <option value="holiday-light">Holiday Lightmode</option>
                            <option value="holiday-dark">Holiday Darkmode</option>
                        </select>
                    </div>
                </div>

                <!-- Style Customization Editor -->
                <div class="exits-section" style="margin-top: 15px;">
                    <div class="exits-header" style="cursor: pointer; user-select: none;" onclick="toggleStyleEditor()">
                        ðŸŽ¨ Customize Colors
                        <span id="style-editor-toggle" style="float: right;">â–²</span>
                    </div>
                    <div id="style-editor-content" style="display: block; padding: 12px;">
                        <!-- Roads -->
                        <div style="margin-bottom: 12px;">
                            <div style="color: #f97316; font-size: 12px; font-weight: bold; margin-bottom: 6px;">Roads</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Highways:</label>
                                <input type="color" id="color-highway" value="#FFA500" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Major Roads:</label>
                                <input type="color" id="color-primary" value="#FFDD88" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Streets:</label>
                                <input type="color" id="color-street" value="#FFFFFF" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                        </div>

                        <!-- Buildings -->
                        <div style="margin-bottom: 12px;">
                            <div style="color: #f97316; font-size: 12px; font-weight: bold; margin-bottom: 6px;">Buildings</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Fill Color:</label>
                                <input type="color" id="color-building" value="#E4DCD0" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                        </div>

                        <!-- Water -->
                        <div style="margin-bottom: 12px;">
                            <div style="color: #f97316; font-size: 12px; font-weight: bold; margin-bottom: 6px;">Water</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Water Bodies:</label>
                                <input type="color" id="color-water" value="#B0D0D6" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Rivers:</label>
                                <input type="color" id="color-waterway" value="#CCE7EA" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <label style="font-size: 11px; color: #ccc;">Parks:</label>
                                <input type="color" id="color-park" value="#C8E6C9" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                        </div>

                        <!-- Map & Text -->
                        <div style="margin-bottom: 12px;">
                            <div style="color: #f97316; font-size: 12px; font-weight: bold; margin-bottom: 6px;">Map & Text</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Background:</label>
                                <input type="color" id="color-background" value="#F5F5F0" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <label style="font-size: 11px; color: #ccc;">Text Labels:</label>
                                <input type="color" id="color-text" value="#333333" style="width: 50px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer;">
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <label style="font-size: 11px; color: #ccc;">Text Size:</label>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="range" id="text-size-slider" min="8" max="26" value="12" style="width: 80px;">
                                    <span id="text-size-value" style="font-size: 11px; color: #f97316; min-width: 30px;">12px</span>
                                </div>
                            </div>
                        </div>

                        <!-- Actions -->
                        <div style="display: flex; gap: 6px; margin-top: 15px;">
                            <button onclick="applyCustomStyle()" style="flex: 1; padding: 8px; background: #f97316; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">Apply</button>
                            <button onclick="saveCustomStyle()" style="padding: 8px 12px; background: #2a2a2a; color: #f97316; border: 1px solid #f97316; border-radius: 4px; cursor: pointer; font-size: 12px;">Save</button>
                            <button onclick="resetStyle()" style="padding: 8px 12px; background: #2a2a2a; color: #ccc; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Map -->
            <div class="right-panel">
                <div class="map-section">
                    <input
                        type="text"
                        class="search-box"
                        id="search-box"
                        placeholder="Navigation Coming Soon"
                        disabled
                    >
                    <div class="map-coordinates" id="map-coordinates">--</div>
                    <div id="map"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

    <script>
        // ==================== PASSWORD PROTECTION ====================
        const CORRECT_PASSWORD = 'TripX9k2'; // Random access password

        // Handle login
        document.addEventListener('DOMContentLoaded', () => {
            const loginForm = document.getElementById('login-form');
            const passwordInput = document.getElementById('password-input');
            const loginButton = document.getElementById('login-button');
            const loginError = document.getElementById('login-error');
            const loginOverlay = document.getElementById('login-overlay');

            // Check if password is in URL (e.g., ?password=TripX9k2)
            const urlParams = new URLSearchParams(window.location.search);
            const urlPassword = urlParams.get('password');

            if (urlPassword === CORRECT_PASSWORD) {
                // Password in URL is correct - skip login screen
                loginOverlay.classList.add('hidden');
                initApp();
                return;
            }

            // Set up manual login form
            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const enteredPassword = passwordInput.value;

                if (enteredPassword === CORRECT_PASSWORD) {
                    // Correct password - hide login and start app
                    loginOverlay.classList.add('hidden');
                    initApp();
                } else {
                    // Wrong password - show error
                    loginError.classList.add('show');
                    passwordInput.value = '';
                    passwordInput.focus();

                    // Hide error after 2 seconds
                    setTimeout(() => {
                        loginError.classList.remove('show');
                    }, 2000);
                }
            });

            loginButton.addEventListener('click', () => {
                loginForm.dispatchEvent(new Event('submit'));
            });
        });

        // ==================== STATE ====================
        let map = null;
        let userMarker = null;
        let exitMarkers = [];

        let currentLocation = null;
        let previousLocation = null;
        let roadInfo = null;
        let nearbyExits = [];
        let weatherData = null;
        let markerAnimation = null; // Track ongoing marker animation
        let lastGPSUpdateTime = null; // Track when GPS updates arrive
        let gpsUpdateIntervals = []; // Rolling average of update intervals
        let currentVelocity = { lat: 0, lng: 0 }; // Velocity in degrees/ms
        let isExtrapolating = false; // Whether we're extrapolating beyond GPS data

        // Speed limit caching
        let speedLimitCache = {
            value: null,        // Cached speed limit in mph
            road: null,         // Road name when cached (e.g., "I25")
            direction: null,    // Direction of travel (N, S, E, W, NE, etc.)
            isCached: false     // Whether current display is from cache
        };

        // Road geometry caching for map-matching and road-following
        let roadGeometryCache = {
            segments: [],           // Array of road segments with geometry
            currentSegment: null,   // Active segment marker is on
            currentPosition: null,  // Current position on road {segmentIndex, progress, lat, lng}
            lastFetch: 0,          // Timestamp of last geometry fetch
            lastFetchLat: null,    // Last fetch location
            lastFetchLng: null
        };

        const UPDATE_INTERVAL = 1000; // Update display every second
        const ROAD_QUERY_INTERVAL = 5000; // Query road info every 5 seconds
        const EXIT_QUERY_INTERVAL = 10000; // Query exits every 10 seconds
        const WEATHER_QUERY_INTERVAL = 300000; // Query weather every 5 minutes
        const SPEED_LIMIT_QUERY_INTERVAL = 10000; // Query speed limit every 10 seconds

        let lastRoadQuery = 0;
        let lastExitQuery = 0;
        let lastWeatherQuery = 0;
        let lastSpeedLimitQuery = 0;

        // ==================== INIT ====================
        function initApp() {
            initMap();
            initGPS();
            loadRadar();
            setInterval(updateDisplay, UPDATE_INTERVAL);
            initRadarOpacitySlider();
            initMapZoomSlider();
            initMapStyleSelector();
            initTextSizeSlider();
            loadSavedColors();
        }

        function initRadarOpacitySlider() {
            const slider = document.getElementById('radar-opacity-slider');
            const valueDisplay = document.getElementById('radar-opacity-value');
            const decreaseBtn = document.getElementById('opacity-decrease');
            const increaseBtn = document.getElementById('opacity-increase');

            // Slider input handler
            slider.addEventListener('input', (e) => {
                const opacity = e.target.value / 100;
                valueDisplay.textContent = `${e.target.value}%`;

                // Update radar layer opacity if it exists
                if (map.getLayer('radar-layer')) {
                    map.setPaintProperty('radar-layer', 'raster-opacity', opacity);
                }
            });

            // Decrease button (-5)
            decreaseBtn.addEventListener('click', () => {
                const currentValue = parseInt(slider.value);
                const newValue = Math.max(0, currentValue - 5);
                slider.value = newValue;
                valueDisplay.textContent = `${newValue}%`;

                if (map.getLayer('radar-layer')) {
                    map.setPaintProperty('radar-layer', 'raster-opacity', newValue / 100);
                }
            });

            // Increase button (+5)
            increaseBtn.addEventListener('click', () => {
                const currentValue = parseInt(slider.value);
                const newValue = Math.min(100, currentValue + 5);
                slider.value = newValue;
                valueDisplay.textContent = `${newValue}%`;

                if (map.getLayer('radar-layer')) {
                    map.setPaintProperty('radar-layer', 'raster-opacity', newValue / 100);
                }
            });
        }

        function initMapZoomSlider() {
            const slider = document.getElementById('map-zoom-slider');
            const valueDisplay = document.getElementById('map-zoom-value');
            const decreaseBtn = document.getElementById('zoom-decrease');
            const increaseBtn = document.getElementById('zoom-increase');

            // Slider input handler
            slider.addEventListener('input', (e) => {
                const zoom = parseInt(e.target.value);
                valueDisplay.textContent = zoom;

                if (map) {
                    map.setZoom(zoom);
                }
            });

            // Decrease button (-1)
            decreaseBtn.addEventListener('click', () => {
                const currentValue = parseInt(slider.value);
                const newValue = Math.max(8, currentValue - 1);
                slider.value = newValue;
                valueDisplay.textContent = newValue;

                if (map) {
                    map.setZoom(newValue);
                }
            });

            // Increase button (+1)
            increaseBtn.addEventListener('click', () => {
                const currentValue = parseInt(slider.value);
                const newValue = Math.min(19, currentValue + 1);
                slider.value = newValue;
                valueDisplay.textContent = newValue;

                if (map) {
                    map.setZoom(newValue);
                }
            });

            // Update slider when map zoom changes (e.g., pinch zoom, scroll wheel)
            if (map) {
                map.on('zoomend', () => {
                    const currentZoom = map.getZoom();
                    slider.value = currentZoom;
                    valueDisplay.textContent = currentZoom;
                });
            }
        }

        // Get predefined theme colors
        function getThemeColors(themeName) {
            const themes = {
                'executive-light': {
                    highway: '#5A5A5A',
                    primary: '#8B8B8B',
                    street: '#CCCCCC',
                    building: '#E8E3D8',
                    water: '#7BA7BC',
                    waterway: '#A5C4D4',
                    park: '#A8C5A0',
                    background: '#F5F5F0',
                    text: '#2C2C2C',
                    textSize: 12
                },
                'executive-dark': {
                    highway: '#CCCCCC',
                    primary: '#999999',
                    street: '#666666',
                    building: '#3A3A3A',
                    water: '#2B4C6F',
                    waterway: '#456B8A',
                    park: '#3D5C3D',
                    background: '#1A1A1A',
                    text: '#E0E0E0',
                    textSize: 12
                },
                'cartoon-light': {
                    highway: '#FF4444',
                    primary: '#FFA500',
                    street: '#FFD700',
                    building: '#9B59B6',
                    water: '#00CED1',
                    waterway: '#87CEEB',
                    park: '#7FFF00',
                    background: '#FFF8DC',
                    text: '#4A235A',
                    textSize: 13
                },
                'cartoon-dark': {
                    highway: '#FF69B4',
                    primary: '#FF6B6B',
                    street: '#FFD93D',
                    building: '#B565D8',
                    water: '#00BFFF',
                    waterway: '#00FFFF',
                    park: '#39FF14',
                    background: '#1C1C3C',
                    text: '#FFFFFF',
                    textSize: 13
                },
                'holiday-light': {
                    highway: '#C41E3A',
                    primary: '#8B0000',
                    street: '#FFFFFF',
                    building: '#F5E6D3',
                    water: '#B0C4DE',
                    waterway: '#D4E4F7',
                    park: '#0F8B3D',
                    background: '#FFFAFA',
                    text: '#1B4D3E',
                    textSize: 12
                },
                'holiday-dark': {
                    highway: '#FF0000',
                    primary: '#DA291C',
                    street: '#98FF98',
                    building: '#3E2723',
                    water: '#1E4D8B',
                    waterway: '#4A90E2',
                    park: '#2D5016',
                    background: '#0D1B0E',
                    text: '#FFD700',
                    textSize: 12
                }
            };
            return themes[themeName] || null;
        }

        function initMapStyleSelector() {
            const selector = document.getElementById('map-style-selector');

            // Load saved style preference
            const savedStyle = localStorage.getItem('map_style') || 'voyager';
            selector.value = savedStyle;

            // Handle style change
            selector.addEventListener('change', async (e) => {
                const newStyle = e.target.value;

                // Save preference
                localStorage.setItem('map_style', newStyle);

                // Check if this is a themed style
                const themeColors = getThemeColors(newStyle);

                if (themeColors) {
                    // Apply themed colors
                    const baseStyleURL = getVectorStyleURL(newStyle);
                    const customStyleJSON = await fetchAndCustomizeStyle(baseStyleURL, themeColors);
                    map.setStyle(customStyleJSON);

                    // Update color pickers to match theme
                    document.getElementById('color-highway').value = themeColors.highway;
                    document.getElementById('color-primary').value = themeColors.primary;
                    document.getElementById('color-street').value = themeColors.street;
                    document.getElementById('color-building').value = themeColors.building;
                    document.getElementById('color-water').value = themeColors.water;
                    document.getElementById('color-waterway').value = themeColors.waterway;
                    document.getElementById('color-park').value = themeColors.park;
                    document.getElementById('color-background').value = themeColors.background;
                    document.getElementById('color-text').value = themeColors.text;
                    document.getElementById('text-size-slider').value = themeColors.textSize;
                    document.getElementById('text-size-value').textContent = themeColors.textSize + 'px';
                } else {
                    // Standard map style (voyager, dark, satellite)
                    map.setStyle(getVectorStyleURL(newStyle));
                }

                // Re-add radar after style loads
                map.once('styledata', () => {
                    loadRadar();
                });

                console.log(`Map style changed to: ${newStyle}`);
            });
        }

        function initTextSizeSlider() {
            const slider = document.getElementById('text-size-slider');
            const valueDisplay = document.getElementById('text-size-value');

            // Slider input handler - update display in real-time
            slider.addEventListener('input', (e) => {
                valueDisplay.textContent = `${e.target.value}px`;
            });
        }

        // Get vector style URL for MapLibre GL JS
        function getVectorStyleURL(styleName) {
            const styles = {
                voyager: 'https://tiles.basemaps.cartocdn.com/gl/voyager-gl-style/style.json',
                dark: 'https://tiles.basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
                satellite: 'https://tiles.basemaps.cartocdn.com/gl/positron-gl-style/style.json'
            };

            // Themed styles use voyager as base
            if (styleName.includes('executive') || styleName.includes('cartoon') || styleName.includes('holiday')) {
                return styles.voyager;
            }

            return styles[styleName] || styles.voyager;
        }

        async function initMap() {
            const savedStyle = localStorage.getItem('map_style') || 'voyager';
            const themeColors = getThemeColors(savedStyle);

            let initialStyle;
            if (themeColors) {
                // Apply themed style on load
                const baseStyleURL = getVectorStyleURL(savedStyle);
                initialStyle = await fetchAndCustomizeStyle(baseStyleURL, themeColors);
            } else {
                initialStyle = getVectorStyleURL(savedStyle);
            }

            map = new maplibregl.Map({
                container: 'map',
                style: initialStyle,
                center: [-122.4194, 37.7749], // [lng, lat] - REVERSED from Leaflet!
                zoom: 18,
                attributionControl: false
            });

            map.on('load', () => {
                console.log('Map loaded successfully');
                loadRadar(); // Add radar after style loads

                // If theme was applied, update color pickers
                if (themeColors) {
                    document.getElementById('color-highway').value = themeColors.highway;
                    document.getElementById('color-primary').value = themeColors.primary;
                    document.getElementById('color-street').value = themeColors.street;
                    document.getElementById('color-building').value = themeColors.building;
                    document.getElementById('color-water').value = themeColors.water;
                    document.getElementById('color-waterway').value = themeColors.waterway;
                    document.getElementById('color-park').value = themeColors.park;
                    document.getElementById('color-background').value = themeColors.background;
                    document.getElementById('color-text').value = themeColors.text;
                    document.getElementById('text-size-slider').value = themeColors.textSize;
                    document.getElementById('text-size-value').textContent = themeColors.textSize + 'px';
                }
            });

            // Update zoom slider when map zooms
            map.on('zoomend', () => {
                const zoom = Math.round(map.getZoom());
                const slider = document.getElementById('map-zoom-slider');
                const valueDisplay = document.getElementById('map-zoom-value');
                if (slider) slider.value = zoom;
                if (valueDisplay) valueDisplay.textContent = zoom;
            });
        }

        function initGPS() {
            if (!('geolocation' in navigator)) {
                updateStatus('GPS not supported', 'error');
                return;
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 0
            };

            navigator.geolocation.watchPosition(
                handleLocationUpdate,
                handleLocationError,
                options
            );
        }

        // ==================== LOCATION UPDATES ====================
        function handleLocationUpdate(position) {
            const coords = position.coords;
            const now = performance.now();

            // Track GPS update intervals for adaptive animation
            if (lastGPSUpdateTime) {
                const interval = now - lastGPSUpdateTime;
                gpsUpdateIntervals.push(interval);

                // Keep rolling window of last 5 intervals
                if (gpsUpdateIntervals.length > 5) {
                    gpsUpdateIntervals.shift();
                }
            }
            lastGPSUpdateTime = now;

            // Save previous location
            if (currentLocation) {
                previousLocation = { ...currentLocation };
            }

            // Calculate speed from position change if not provided by GPS
            let calculatedSpeed = coords.speed; // m/s
            if ((calculatedSpeed === null || calculatedSpeed === undefined) && previousLocation && lastGPSUpdateTime) {
                const timeDelta = (now - lastGPSUpdateTime) / 1000; // seconds
                if (timeDelta > 0) {
                    const distance = calculateDistance(
                        previousLocation.lat,
                        previousLocation.lng,
                        coords.latitude,
                        coords.longitude
                    ); // distance in miles
                    calculatedSpeed = (distance * 1609.34) / timeDelta; // convert miles to meters, then m/s
                }
            }

            // Update current location
            currentLocation = {
                lat: coords.latitude,
                lng: coords.longitude,
                speed: calculatedSpeed, // m/s (from GPS or calculated)
                heading: coords.heading, // degrees
                accuracy: coords.accuracy, // meters
                altitude: coords.altitude, // meters
                altitudeAccuracy: coords.altitudeAccuracy,
                timestamp: position.timestamp
            };

            // Update map marker
            updateMapMarker();

            // Update status
            updateStatus('GPS Active', 'active');

            // Query road info periodically
            const currentTime = Date.now();
            if (currentTime - lastRoadQuery > ROAD_QUERY_INTERVAL) {
                lastRoadQuery = currentTime;
                queryRoadInfo();
            }

            // Query nearby exits periodically
            if (currentTime - lastExitQuery > EXIT_QUERY_INTERVAL) {
                lastExitQuery = currentTime;
                queryNearbyExits();
            }

            // Query weather periodically
            if (currentTime - lastWeatherQuery > WEATHER_QUERY_INTERVAL) {
                lastWeatherQuery = currentTime;
                queryWeather();
            }

            // Query speed limit periodically
            if (currentTime - lastSpeedLimitQuery > SPEED_LIMIT_QUERY_INTERVAL) {
                lastSpeedLimitQuery = currentTime;
                querySpeedLimit();
            }
        }

        function handleLocationError(error) {
            console.error('GPS Error:', error);
            updateStatus('GPS Error', 'error');
        }

        function getAverageGPSInterval() {
            if (gpsUpdateIntervals.length === 0) return 1000; // Default 1 second
            const sum = gpsUpdateIntervals.reduce((a, b) => a + b, 0);
            return sum / gpsUpdateIntervals.length;
        }

        // ==================== MAP MARKER ====================
        function animateMarkerAlongRoad() {
            // Cancel any ongoing animation
            if (markerAnimation) {
                cancelAnimationFrame(markerAnimation);
                markerAnimation = null;
            }

            if (!currentLocation) return;

            const startTime = performance.now();
            let lastUpdateTime = startTime;

            function animate(currentTime) {
                const elapsedSinceLastUpdate = currentTime - lastUpdateTime;
                lastUpdateTime = currentTime;

                // Check if vehicle is moving
                if (!currentLocation || currentLocation.speed < 0.5) {
                    // Stationary - stop animation
                    markerAnimation = null;
                    isExtrapolating = false;
                    return;
                }

                // Try road-following if we have geometry
                if (roadGeometryCache.currentPosition && roadGeometryCache.currentPosition.segment) {
                    const newPosition = extrapolateAlongRoad(
                        roadGeometryCache.currentPosition,
                        currentLocation.speed,
                        elapsedSinceLastUpdate
                    );

                    if (newPosition) {
                        // Update marker position
                        userMarker.setLngLat([newPosition.lng, newPosition.lat]); // [lng, lat] - REVERSED!

                        // Update cache
                        roadGeometryCache.currentPosition = newPosition;

                        // Continue animation
                        isExtrapolating = true;
                        markerAnimation = requestAnimationFrame(animate);
                        return;
                    }
                }

                // Fallback: straight-line extrapolation if no road geometry
                if (currentVelocity.lat !== 0 || currentVelocity.lng !== 0) {
                    const currentPos = userMarker.getLngLat(); // Returns {lng, lat}
                    const lat = currentPos.lat + (currentVelocity.lat * elapsedSinceLastUpdate);
                    const lng = currentPos.lng + (currentVelocity.lng * elapsedSinceLastUpdate);

                    userMarker.setLngLat([lng, lat]); // [lng, lat] - REVERSED!
                    isExtrapolating = true;
                    markerAnimation = requestAnimationFrame(animate);
                }
            }

            markerAnimation = requestAnimationFrame(animate);
        }

        function smoothTransitionTo(targetLat, targetLng, duration = 500) {
            // Cancel ongoing animation
            if (markerAnimation) {
                cancelAnimationFrame(markerAnimation);
                markerAnimation = null;
            }

            const currentPos = userMarker.getLngLat(); // Returns {lng, lat}
            const startLat = currentPos.lat;
            const startLng = currentPos.lng;
            const startTime = performance.now();

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease-out cubic

                const lat = startLat + (targetLat - startLat) * easeProgress;
                const lng = startLng + (targetLng - startLng) * easeProgress;

                userMarker.setLngLat([lng, lat]); // [lng, lat] - REVERSED!

                if (progress < 1) {
                    markerAnimation = requestAnimationFrame(animate);
                } else {
                    // Transition complete, restart road-following
                    animateMarkerAlongRoad();
                }
            }

            markerAnimation = requestAnimationFrame(animate);
        }

        async function updateMapMarker() {
            if (!currentLocation) return;

            const newLat = currentLocation.lat;
            const newLng = currentLocation.lng;
            const now = performance.now();

            // Fetch road geometry if needed (every 30 seconds or if moved far)
            const needsGeometryFetch =
                !roadGeometryCache.segments.length ||
                (now - roadGeometryCache.lastFetch > 30000) ||
                (roadGeometryCache.lastFetchLat &&
                 calculateDistance(newLat, newLng, roadGeometryCache.lastFetchLat, roadGeometryCache.lastFetchLng) > 0.5); // > 0.5 miles

            if (needsGeometryFetch) {
                roadGeometryCache.lastFetchLat = newLat;
                roadGeometryCache.lastFetchLng = newLng;
                roadGeometryCache.lastFetch = now;

                // Await the fetch to ensure we have geometry before map-matching
                const segments = await fetchRoadGeometry(newLat, newLng);
                roadGeometryCache.segments = segments;
                console.log(`Road geometry updated: ${segments.length} segments`);
            }

            // Map-match GPS to road
            const matchedPosition = findNearestPointOnRoad(newLat, newLng, roadGeometryCache.segments);

            if (userMarker) {
                // Get current marker position
                const currentLatLng = userMarker.getLngLat(); // Returns {lng, lat}
                const currentLat = currentLatLng.lat;
                const currentLng = currentLatLng.lng;

                // Calculate distance moved
                const distanceMoved = calculateDistance(currentLat, currentLng, newLat, newLng);

                if (distanceMoved < 0.00001) {
                    // Tiny movement - ignore to prevent jitter
                    return;
                }

                if (matchedPosition) {
                    // Road-following mode
                    const distanceFromMarkerToMatched = calculateDistance(
                        currentLat, currentLng,
                        matchedPosition.lat, matchedPosition.lng
                    );

                    // Update road position cache FIRST (so animation uses new target)
                    roadGeometryCache.currentPosition = matchedPosition;
                    roadGeometryCache.currentSegment = matchedPosition.segment;

                    // Calculate velocity for fallback straight-line extrapolation
                    const avgInterval = getAverageGPSInterval();
                    currentVelocity.lat = (matchedPosition.lat - currentLat) / avgInterval;
                    currentVelocity.lng = (matchedPosition.lng - currentLng) / avgInterval;

                    // Only do hard correction if VERY far off (>50m), otherwise let animation catch up
                    if (distanceFromMarkerToMatched > 0.0003) {
                        // More than ~30m off - instant correction (probably GPS jumped or changed roads)
                        userMarker.setLngLat([matchedPosition.lng, matchedPosition.lat]); // [lng, lat] - REVERSED!
                    }
                    // Otherwise, just let the animation naturally move toward the new position

                    // Ensure animation is running if moving
                    if (currentLocation.speed > 0.5 && !markerAnimation) {
                        animateMarkerAlongRoad();
                    }
                } else {
                    // No road geometry - fallback to straight-line
                    const avgInterval = getAverageGPSInterval();
                    currentVelocity.lat = (newLat - currentLat) / avgInterval;
                    currentVelocity.lng = (newLng - currentLng) / avgInterval;

                    smoothTransitionTo(newLat, newLng, 500);
                }
            } else {
                // First time: create marker
                const initialLat = matchedPosition ? matchedPosition.lat : newLat;
                const initialLng = matchedPosition ? matchedPosition.lng : newLng;

                // Create custom marker element for MapLibre
                const markerEl = document.createElement('div');
                markerEl.className = 'user-marker';
                markerEl.style.width = '20px';
                markerEl.style.height = '20px';
                markerEl.style.borderRadius = '50%';
                markerEl.style.backgroundColor = '#4285F4';
                markerEl.style.border = '3px solid #ffffff';
                markerEl.style.boxShadow = '0 0 6px rgba(0,0,0,0.4)';

                userMarker = new maplibregl.Marker({
                    element: markerEl,
                    anchor: 'center'
                })
                .setLngLat([initialLng, initialLat]) // [lng, lat] - REVERSED!
                .addTo(map);

                // Center map on initial position
                map.jumpTo({center: [initialLng, initialLat], zoom: 15}); // [lng, lat] - REVERSED!

                if (matchedPosition) {
                    roadGeometryCache.currentPosition = matchedPosition;
                    roadGeometryCache.currentSegment = matchedPosition.segment;
                }

                // Start animation if moving
                if (currentLocation.speed > 0.5) {
                    animateMarkerAlongRoad();
                }
            }

            // Re-center map smoothly
            const targetLat = matchedPosition ? matchedPosition.lat : newLat;
            const targetLng = matchedPosition ? matchedPosition.lng : newLng;
            map.easeTo({center: [targetLng, targetLat], duration: 500}); // [lng, lat] - REVERSED!
        }

        // ==================== ROAD INFO QUERY ====================
        async function queryRoadInfo() {
            if (!currentLocation) return;

            try {
                // Use Nominatim reverse geocoding (zoom 18 for detailed road info)
                const url = `https://nominatim.openstreetmap.org/reverse?` +
                    `format=json&lat=${currentLocation.lat}&lon=${currentLocation.lng}&zoom=18&addressdetails=1`;

                const response = await fetch(url, {
                    headers: { 'User-Agent': 'Road Trip Telemetry' }
                });

                if (!response.ok) return;

                const data = await response.json();

                // Extract city from detailed query
                let city = data.address?.city || data.address?.town || data.address?.village || 'Unknown';

                // If city is Unknown, try broader zoom to find nearest city
                if (city === 'Unknown') {
                    try {
                        const broadUrl = `https://nominatim.openstreetmap.org/reverse?` +
                            `format=json&lat=${currentLocation.lat}&lon=${currentLocation.lng}&zoom=10`;

                        const broadResponse = await fetch(broadUrl, {
                            headers: { 'User-Agent': 'Road Trip Telemetry' }
                        });

                        if (broadResponse.ok) {
                            const broadData = await broadResponse.json();
                            const nearestCity = broadData.address?.city ||
                                               broadData.address?.town ||
                                               broadData.address?.village ||
                                               broadData.address?.county;

                            if (nearestCity) {
                                city = `Near ${nearestCity}`;
                            }
                        }
                    } catch (broadError) {
                        console.log('Broad city query failed, keeping Unknown');
                    }
                }

                // Extract highway number and name separately
                // Priority: motorway > trunk > primary > road
                const motorway = data.address?.motorway;
                const trunk = data.address?.trunk;
                const primary = data.address?.primary;
                const road = data.address?.road;

                // Determine which field contains the highway NUMBER
                let highwayNumber = motorway || trunk || primary;

                // If no dedicated highway field, road might be the highway number
                if (!highwayNumber && road) {
                    // Check if road field looks like a highway number
                    const roadLower = road.toLowerCase();
                    if (roadLower.includes('interstate') || roadLower.includes('highway') ||
                        roadLower.match(/^(i-|us-|sr-|sh-|fm\s*\d+)/i)) {
                        highwayNumber = road;
                    }
                }

                // Determine which field contains the highway NAME (not the number)
                let highwayName = null;
                if (road && road !== highwayNumber) {
                    // Road field contains the name, not the number
                    const roadLower = road.toLowerCase();
                    // Make sure it's not also a highway number
                    if (!roadLower.includes('interstate') && !roadLower.includes('highway') &&
                        !roadLower.match(/^(i-|us-|sr-|sh-|fm\s*\d+)/i)) {
                        highwayName = road;
                    }
                }

                roadInfo = {
                    road: highwayNumber || road || 'Unknown',  // The highway number
                    roadName: highwayName || null,  // The highway name (separate)
                    highwayNumber: highwayNumber || null,  // Explicitly store highway number
                    houseNumber: data.address?.house_number || null,
                    city: city,
                    state: data.address?.state || '',
                    type: determineRoadType(data)
                };

                console.log('Road info:', roadInfo);
            } catch (error) {
                console.error('Road query failed:', error);
            }
        }

        function determineRoadType(data) {
            const address = data.address || {};

            // Check motorway field first (most reliable for interstates/highways)
            if (address.motorway) {
                const motorway = address.motorway.toLowerCase();
                if (motorway.includes('interstate')) {
                    return 'Interstate';
                } else {
                    return 'Highway';
                }
            }

            // Check trunk roads (major highways)
            if (address.trunk) {
                return 'Highway';
            }

            // Check primary roads (could be FM/RM roads or state highways)
            if (address.primary) {
                return 'Highway';
            }

            // Fall back to road name string matching
            const road = (address.road || '').toLowerCase();

            if (road.includes('interstate') || road.includes('i-')) {
                return 'Interstate';
            } else if (road.includes('highway') || road.includes('us-') || road.includes('state route') ||
                       road.match(/^fm\s*\d+/i) || road.match(/^rm\s*\d+/i)) {
                return 'Highway';
            } else if (road.includes('freeway') || road.includes('expressway')) {
                return 'Freeway';
            } else if (address.road) {
                return 'Surface Street';
            }

            return 'Unknown';
        }

        function formatHighwayName(name) {
            if (!name) return name;

            let formatted = name;

            // Convert "Interstate 25" â†’ "I25"
            // Convert "Interstate 35 E" â†’ "I35E"
            formatted = formatted.replace(/Interstate\s+(\d+)\s*([NESW])?/gi, 'I$1$2');

            // Convert "US Highway 287" â†’ "US287"
            formatted = formatted.replace(/US\s+Highway\s+(\d+)\s*([NESW])?/gi, 'US$1$2');

            // Convert "State Highway 114" â†’ "SH114"
            formatted = formatted.replace(/State\s+Highway\s+(\d+)\s*([NESW])?/gi, 'SH$1$2');

            // Convert "FM 2499" â†’ "FM2499" (Farm-to-Market roads)
            formatted = formatted.replace(/FM\s+(\d+)/gi, 'FM$1');

            // Convert "RM 1431" â†’ "RM1431" (Ranch-to-Market roads)
            formatted = formatted.replace(/RM\s+(\d+)/gi, 'RM$1');

            // Remove extra spaces
            formatted = formatted.trim().replace(/\s+/g, ' ');

            return formatted;
        }

        function getCardinalDirection(heading) {
            if (heading === null || heading === undefined) return null;

            // Convert heading to cardinal direction (8 directions)
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const index = Math.round(heading / 45) % 8;
            return directions[index];
        }

        // ==================== ROAD GEOMETRY & MAP MATCHING ====================
        async function fetchRoadGeometry(lat, lng, radius = 150) {
            try {
                const query = `
                    [out:json][timeout:5];
                    way(around:${radius},${lat},${lng})["highway"];
                    out geom;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                if (!response.ok) return [];

                const data = await response.json();

                // Parse geometry data
                const segments = data.elements
                    .filter(el => el.type === 'way' && el.geometry && el.geometry.length > 1)
                    .map(el => ({
                        id: el.id,
                        tags: el.tags || {},
                        geometry: el.geometry.map(node => ({
                            lat: node.lat,
                            lng: node.lon
                        }))
                    }));

                console.log(`Fetched ${segments.length} road segments with geometry`);
                return segments;
            } catch (error) {
                console.error('Road geometry fetch failed:', error);
                return [];
            }
        }

        function projectPointOntoLine(pointLat, pointLng, lineStart, lineEnd) {
            // Project point onto line segment and return closest point + progress (0-1)
            const A = {lat: pointLat, lng: pointLng};
            const B = {lat: lineStart.lat, lng: lineStart.lng};
            const C = {lat: lineEnd.lat, lng: lineEnd.lng};

            // Vector BC
            const BC_lat = C.lat - B.lat;
            const BC_lng = C.lng - B.lng;

            // Vector BA
            const BA_lat = A.lat - B.lat;
            const BA_lng = A.lng - B.lng;

            // Dot product
            const dot = BA_lat * BC_lat + BA_lng * BC_lng;

            // Length squared of BC
            const lenSq = BC_lat * BC_lat + BC_lng * BC_lng;

            // Parameter t (0-1) along line segment
            let t = dot / lenSq;

            // Clamp to [0, 1] to stay on line segment
            t = Math.max(0, Math.min(1, t));

            // Calculate projected point
            const projectedLat = B.lat + t * BC_lat;
            const projectedLng = B.lng + t * BC_lng;

            return {
                lat: projectedLat,
                lng: projectedLng,
                progress: t
            };
        }

        function findNearestPointOnRoad(gpsLat, gpsLng, roadSegments) {
            if (!roadSegments || roadSegments.length === 0) return null;

            let nearest = null;
            let minDistance = Infinity;

            for (const segment of roadSegments) {
                for (let i = 0; i < segment.geometry.length - 1; i++) {
                    const p1 = segment.geometry[i];
                    const p2 = segment.geometry[i + 1];

                    // Project GPS point onto this line segment
                    const projected = projectPointOntoLine(gpsLat, gpsLng, p1, p2);
                    const distance = calculateDistance(gpsLat, gpsLng, projected.lat, projected.lng);

                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = {
                            segment: segment,
                            segmentIndex: i,
                            position: projected,
                            lat: projected.lat,
                            lng: projected.lng,
                            progress: projected.progress,
                            distance: distance
                        };
                    }
                }
            }

            return nearest;
        }

        function extrapolateAlongRoad(currentPos, speed, elapsedTime) {
            if (!currentPos || !currentPos.segment) {
                return null;
            }

            // Speed in m/s, elapsedTime in ms
            const distanceToMove = (speed * elapsedTime) / 1000; // meters

            // Convert to degrees (approximate - varies by latitude)
            const degreesToMove = distanceToMove / 111320;

            // Walk along road geometry from current position
            let remainingDistance = degreesToMove;
            let segmentIndex = currentPos.segmentIndex;
            let progress = currentPos.progress;
            const geometry = currentPos.segment.geometry;

            while (remainingDistance > 0 && segmentIndex < geometry.length - 1) {
                const p1 = geometry[segmentIndex];
                const p2 = geometry[segmentIndex + 1];

                // Distance remaining in current segment
                const segmentLength = calculateDistance(p1.lat, p1.lng, p2.lat, p2.lng);
                const remainingInSegment = segmentLength * (1 - progress);

                if (remainingDistance < remainingInSegment) {
                    // Move within current segment
                    progress += remainingDistance / segmentLength;
                    remainingDistance = 0;
                } else {
                    // Move to next segment
                    remainingDistance -= remainingInSegment;
                    segmentIndex++;
                    progress = 0;
                }

                // Safety: don't go past end of road
                if (segmentIndex >= geometry.length - 1) {
                    segmentIndex = geometry.length - 2;
                    progress = 1;
                    break;
                }
            }

            // Interpolate position on segment
            const p1 = geometry[segmentIndex];
            const p2 = geometry[segmentIndex + 1];

            return {
                lat: p1.lat + (p2.lat - p1.lat) * progress,
                lng: p1.lng + (p2.lng - p1.lng) * progress,
                segmentIndex: segmentIndex,
                progress: progress,
                segment: currentPos.segment
            };
        }

        // ==================== SPEED LIMIT QUERY ====================
        async function querySpeedLimit() {
            if (!currentLocation) return;

            try {
                // Query Overpass for nearby ways with maxspeed within 100m (wider search for highways)
                const query = `
                    [out:json][timeout:5];
                    way(around:100,${currentLocation.lat},${currentLocation.lng})["highway"]["maxspeed"];
                    out tags;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                if (!response.ok) return;

                const data = await response.json();

                if (data.elements && data.elements.length > 0) {
                    // Get the first way with maxspeed
                    const way = data.elements[0];
                    let speedLimit = way.tags.maxspeed;

                    if (speedLimit) {
                        // Parse speed limit value
                        speedLimit = parseSpeedLimit(speedLimit);

                        // Update cache with new data - use highway number if available
                        if (roadInfo) {
                            const roadKey = roadInfo.highwayNumber ?
                                formatHighwayName(roadInfo.highwayNumber) :
                                formatHighwayName(roadInfo.road);
                            const direction = getCardinalDirection(currentLocation.heading);

                            speedLimitCache = {
                                value: speedLimit,
                                road: roadKey,
                                direction: direction,
                                isCached: false  // Fresh data, not cached
                            };
                        }

                        // Update roadInfo with speed limit
                        if (roadInfo) {
                            roadInfo.speedLimit = speedLimit;
                        } else {
                            roadInfo = { speedLimit: speedLimit };
                        }

                        console.log('Speed limit found:', speedLimit);
                        return;
                    }
                }

                // No speed limit found - check if we should use cached value
                if (speedLimitCache.value && roadInfo) {
                    // Use highway number if available, otherwise use road
                    const currentRoadKey = roadInfo.highwayNumber ?
                        formatHighwayName(roadInfo.highwayNumber) :
                        (roadInfo.road ? formatHighwayName(roadInfo.road) : null);

                    if (currentRoadKey) {
                        // KEEP cached value if we're on the same road (ignore direction changes)
                        if (speedLimitCache.road === currentRoadKey) {
                            // Same road - keep showing speed limit regardless of direction
                            roadInfo.speedLimit = speedLimitCache.value;
                            speedLimitCache.isCached = true;  // Mark as cached
                            console.log('Using cached speed limit:', speedLimitCache.value, 'for', currentRoadKey);
                            return;
                        } else {
                            // Different road - clear the speed limit (changed roads via turn/ramp)
                            console.log('Road changed from', speedLimitCache.road, 'to', currentRoadKey, '- clearing speed limit');
                            roadInfo.speedLimit = null;
                            speedLimitCache.isCached = false;
                        }
                    } else {
                        // No current road info - clear speed limit display
                        roadInfo.speedLimit = null;
                        speedLimitCache.isCached = false;
                    }
                } else {
                    // No cache available - clear speed limit display
                    if (roadInfo) {
                        roadInfo.speedLimit = null;
                    }
                    speedLimitCache.isCached = false;
                }

            } catch (error) {
                console.error('Speed limit query failed:', error);

                // On error, try to use cached value if available and on same road
                if (speedLimitCache.value && roadInfo) {
                    const currentRoadKey = roadInfo.highwayNumber ?
                        formatHighwayName(roadInfo.highwayNumber) :
                        (roadInfo.road ? formatHighwayName(roadInfo.road) : null);

                    if (currentRoadKey && speedLimitCache.road === currentRoadKey) {
                        roadInfo.speedLimit = speedLimitCache.value;
                        speedLimitCache.isCached = true;
                        console.log('Using cached speed limit (error fallback):', speedLimitCache.value);
                    }
                }
            }
        }

        function parseSpeedLimit(maxspeedValue) {
            // Parse maxspeed tag value into mph
            // Examples: "55 mph", "100" (km/h), "50 knots"

            const value = maxspeedValue.trim();

            // Check for mph
            if (value.includes('mph')) {
                return parseInt(value);
            }

            // Check for knots
            if (value.includes('knots')) {
                const knots = parseInt(value);
                return Math.round(knots * 1.15078); // Convert knots to mph
            }

            // Default is km/h - convert to mph
            const kmh = parseInt(value);
            if (!isNaN(kmh)) {
                return Math.round(kmh * 0.621371);
            }

            return null;
        }

        // ==================== NEARBY EXITS QUERY ====================
        async function getRoadNameForExit(lat, lng) {
            try {
                const url = `https://nominatim.openstreetmap.org/reverse?` +
                    `format=json&lat=${lat}&lon=${lng}&zoom=18`;

                const response = await fetch(url, {
                    headers: { 'User-Agent': 'Road Trip Telemetry' }
                });

                if (!response.ok) return null;

                const data = await response.json();

                // Look for the most relevant road name
                const address = data.address || {};

                // Priority: road > street > residential > highway
                const roadName = address.road ||
                                address.street ||
                                address.residential ||
                                address.highway ||
                                address.motorway;

                return roadName || null;
            } catch (error) {
                console.error('Geocoding failed for exit:', error);
                return null;
            }
        }

        async function queryNearbyExits() {
            if (!currentLocation) return;

            try {
                // Query Overpass for motorway junctions within 800m (0.5 mi)
                const query = `
                    [out:json][timeout:5];
                    (
                        node["highway"="motorway_junction"](around:800,${currentLocation.lat},${currentLocation.lng});
                    );
                    out body;
                    >;
                    out skel qt;
                `;

                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                if (!response.ok) return;

                const data = await response.json();

                const exitNodes = data.elements
                    .filter(element => element.type === 'node' && element.tags)
                    .map(element => {
                        const distance = calculateDistance(
                            currentLocation.lat,
                            currentLocation.lng,
                            element.lat,
                            element.lon
                        );

                        return {
                            id: element.id,
                            lat: element.lat,
                            lng: element.lon,
                            distance: distance,
                            tags: element.tags,
                            needsGeocode: !element.tags.ref && !element.tags.name && !element.tags.destination
                        };
                    });

                // Fetch street names for unnamed exits
                const exitPromises = exitNodes.map(async (element) => {
                    let exitName = 'Exit';
                    let destination = null;

                    // Build exit name with multiple fallbacks
                    if (element.tags.ref) {
                        exitName = `Exit ${element.tags.ref}`;
                    } else if (element.tags.name) {
                        exitName = element.tags.name;
                    } else if (element.tags.destination) {
                        exitName = `Exit to ${element.tags.destination}`;
                        destination = element.tags.destination;
                    } else if (element.needsGeocode) {
                        // Fetch street name via reverse geocoding
                        const streetName = await getRoadNameForExit(element.lat, element.lng);
                        if (streetName) {
                            exitName = `Exit towards ${streetName}`;
                        } else {
                            exitName = 'Exit (unsigned)';
                        }
                    } else if (element.tags['noref'] === 'yes' || element.tags['unsigned_ref']) {
                        exitName = `Exit ${element.tags.unsigned_ref || '(unsigned)'}`;
                    }

                    // Add destination info if available and not already set
                    if (!destination) {
                        if (element.tags.destination) {
                            destination = element.tags.destination;
                        } else if (element.tags['destination:ref']) {
                            destination = element.tags['destination:ref'];
                        } else if (element.tags['destination:street']) {
                            destination = element.tags['destination:street'];
                        }
                    }

                    // Determine if this is an exit (off-ramp) or entrance (on-ramp)
                    // motorway_junction nodes are ALWAYS exits (leaving the motorway)
                    // Only mark as entrance if explicitly tagged as such
                    const isEntrance = element.tags.highway === 'motorway_link' &&
                                      !element.tags.destination &&
                                      !element.tags['destination:ref'] &&
                                      !element.tags['destination:street'];
                    const isExit = !isEntrance;  // Default to exit for motorway_junction nodes

                    return {
                        id: element.id,
                        name: exitName,
                        destination: destination,
                        ref: element.tags.ref || null,
                        lat: element.lat,
                        lng: element.lng,
                        distance: element.distance,
                        tags: element.tags,
                        type: isExit ? 'exit' : 'entrance'  // NEW: Add type classification
                    };
                });

                nearbyExits = await Promise.all(exitPromises);

                // Sort by distance
                nearbyExits.sort((a, b) => a.distance - b.distance);

                console.log('Nearby exits found:', nearbyExits.length);
                updateExitsDisplay();
            } catch (error) {
                console.error('Exit query failed:', error);
            }
        }

        // ==================== WEATHER QUERY ====================
        async function queryWeather() {
            if (!currentLocation) return;

            try {
                // Use Open-Meteo API (completely free, no API key needed, real data)
                const url = `https://api.open-meteo.com/v1/forecast?` +
                    `latitude=${currentLocation.lat}&` +
                    `longitude=${currentLocation.lng}&` +
                    `current=temperature_2m,apparent_temperature,relative_humidity_2m,weather_code,wind_speed_10m,wind_direction_10m,wind_gusts_10m&` +
                    `daily=sunrise,sunset&` +
                    `timezone=auto&` +
                    `temperature_unit=fahrenheit&` +
                    `wind_speed_unit=mph`;

                const response = await fetch(url);
                if (!response.ok) return;

                const data = await response.json();
                const current = data.current;
                const daily = data.daily;

                weatherData = {
                    temp: current.temperature_2m,
                    feelsLike: current.apparent_temperature,
                    humidity: current.relative_humidity_2m,
                    windSpeed: current.wind_speed_10m,
                    windGust: current.wind_gusts_10m,
                    windDirection: current.wind_direction_10m,
                    condition: getWeatherCondition(current.weather_code),
                    sunrise: daily.sunrise[0],  // Today's sunrise (ISO 8601 format)
                    sunset: daily.sunset[0]     // Today's sunset (ISO 8601 format)
                };

                updateWeatherDisplay();
                console.log('Weather updated:', weatherData);
            } catch (error) {
                console.error('Weather query failed:', error);
            }
        }

        function getWeatherCondition(code) {
            // WMO Weather interpretation codes
            const conditions = {
                0: 'Clear',
                1: 'Mostly Clear',
                2: 'Partly Cloudy',
                3: 'Cloudy',
                45: 'Foggy',
                48: 'Rime Fog',
                51: 'Light Drizzle',
                53: 'Drizzle',
                55: 'Heavy Drizzle',
                61: 'Light Rain',
                63: 'Rain',
                65: 'Heavy Rain',
                71: 'Light Snow',
                73: 'Snow',
                75: 'Heavy Snow',
                77: 'Snow Grains',
                80: 'Light Showers',
                81: 'Showers',
                82: 'Heavy Showers',
                85: 'Light Snow Showers',
                86: 'Snow Showers',
                95: 'Thunderstorm',
                96: 'Thunderstorm w/ Hail',
                99: 'Severe Thunderstorm'
            };
            return conditions[code] || 'Unknown';
        }

        function getWindDirection(degrees) {
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
                                'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round(degrees / 22.5) % 16;
            return 'From ' + directions[index];
        }

        function updateWeatherDisplay() {
            if (!weatherData) return;

            document.getElementById('weather-temp').textContent = weatherData.temp.toFixed(0);
            document.getElementById('weather-feels').textContent = weatherData.feelsLike.toFixed(0);
            document.getElementById('weather-humidity').textContent = weatherData.humidity;
            document.getElementById('weather-wind').textContent = weatherData.windSpeed.toFixed(0);

            // Display wind gust
            if (weatherData.windGust !== null && weatherData.windGust !== undefined) {
                document.getElementById('weather-wind-gust').innerHTML = `Gusts <span style="color: #f97316;">${weatherData.windGust.toFixed(0)}</span> mph`;
            } else {
                document.getElementById('weather-wind-gust').textContent = 'No gusts';
            }

            document.getElementById('weather-wind-dir').textContent = getWindDirection(weatherData.windDirection);
            document.getElementById('weather-condition').textContent = weatherData.condition;

            // Rotate wind arrow to show where wind is blowing (opposite of where it's coming from)
            // If wind is "From SSE" (157.5Â°), arrow points NNW (157.5Â° + 180Â° = 337.5Â°)
            const windArrow = document.getElementById('wind-arrow');
            if (weatherData.windDirection !== null && weatherData.windDirection !== undefined) {
                windArrow.style.transform = `rotate(${weatherData.windDirection + 180}deg)`;
                windArrow.style.opacity = '1';
            } else {
                windArrow.style.opacity = '0.3';
            }

            // Update sunrise/sunset
            if (weatherData.sunrise && weatherData.sunset) {
                const now = new Date();
                const sunrise = new Date(weatherData.sunrise);
                const sunset = new Date(weatherData.sunset);
                const sunsetPlus30 = new Date(sunset.getTime() + 30 * 60 * 1000); // 30 minutes after sunset

                const sunLabelEl = document.getElementById('sun-label');
                const sunTimeEl = document.getElementById('sun-time');

                // Determine what to show based on time of day
                if (now < sunrise) {
                    // Before sunrise - show sunrise
                    sunLabelEl.textContent = 'Sunrise';
                    sunTimeEl.textContent = formatTime(sunrise);
                    sunTimeEl.style.opacity = '1';
                    sunTimeEl.style.color = '#f97316';
                } else if (now >= sunrise && now < sunset) {
                    // After sunrise, before sunset - show sunset
                    sunLabelEl.textContent = 'Sunset';
                    sunTimeEl.textContent = formatTime(sunset);
                    sunTimeEl.style.opacity = '1';
                    sunTimeEl.style.color = '#f97316';
                } else if (now >= sunset && now < sunsetPlus30) {
                    // Within 30 minutes after sunset - show sunset with different styling
                    sunLabelEl.textContent = 'Sunset (passed)';
                    sunTimeEl.textContent = formatTime(sunset);
                    sunTimeEl.style.opacity = '0.6';
                    sunTimeEl.style.color = '#999';
                } else {
                    // More than 30 minutes after sunset - show next sunrise
                    sunLabelEl.textContent = 'Sunrise (tomorrow)';
                    const tomorrowSunrise = new Date(sunrise.getTime() + 24 * 60 * 60 * 1000);
                    sunTimeEl.textContent = formatTime(tomorrowSunrise);
                    sunTimeEl.style.opacity = '1';
                    sunTimeEl.style.color = '#f97316';
                }
            }
        }

        function formatTime(date) {
            // Format as 12-hour time (e.g., "6:45 PM")
            let hours = date.getHours();
            const minutes = date.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // 0 should be 12
            const minutesStr = minutes < 10 ? '0' + minutes : minutes;
            return `${hours}:${minutesStr} ${ampm}`;
        }

        // ==================== RADAR OVERLAY ====================
        async function loadRadar() {
            try {
                // Fetch latest radar data from RainViewer API
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                if (!response.ok) {
                    console.error('Failed to fetch radar data');
                    return;
                }

                const data = await response.json();

                // Get the latest radar frame (most recent past frame)
                if (!data.radar || !data.radar.past || data.radar.past.length === 0) {
                    console.error('No radar data available');
                    return;
                }

                // Use the most recent frame
                const latestFrame = data.radar.past[data.radar.past.length - 1];

                // Construct tile URL
                const tileUrl = `${data.host}${latestFrame.path}/256/{z}/{x}/{y}/6/1_1.png`;

                // Remove existing radar layer/source if present
                if (map.getLayer('radar-layer')) {
                    map.removeLayer('radar-layer');
                }
                if (map.getSource('radar')) {
                    map.removeSource('radar');
                }

                // Add radar source
                map.addSource('radar', {
                    type: 'raster',
                    tiles: [tileUrl],
                    tileSize: 256,
                    minzoom: 0,
                    maxzoom: 8  // RainViewer provides tiles up to zoom 8
                });

                // Get current opacity from slider
                const slider = document.getElementById('radar-opacity-slider');
                const currentOpacity = slider ? slider.value / 100 : 0.6;

                // Find first symbol layer (for proper stacking above terrain, below labels)
                const layers = map.getStyle().layers;
                const firstSymbolLayer = layers.find(l => l.type === 'symbol');

                // Add radar layer
                map.addLayer({
                    id: 'radar-layer',
                    type: 'raster',
                    source: 'radar',
                    paint: {
                        'raster-opacity': currentOpacity
                    }
                }, firstSymbolLayer ? firstSymbolLayer.id : undefined);

                console.log('Radar overlay loaded successfully');
            } catch (error) {
                console.error('Error loading radar:', error);
            }
        }

        // ==================== DISPLAY UPDATES ====================
        // Auto-zoom state tracking
        let autoZoomState = {
            isZoomedOut: false,  // Track if we're currently in the zoomed-out state
            lastSpeed: 0
        };

        function handleAutoZoom(speedMph) {
            // Convert speedMph to number (it might be '--' string)
            const speed = speedMph === '--' ? 0 : parseFloat(speedMph);

            if (!map) return;

            const SPEED_THRESHOLD = 55;  // MPH
            const HIGH_SPEED_ZOOM = 17;
            const NORMAL_ZOOM = 18;
            const ANIMATION_DURATION = 3;  // seconds

            // Check if we need to zoom out (going fast)
            if (speed > SPEED_THRESHOLD && !autoZoomState.isZoomedOut) {
                // Speed exceeded threshold - zoom out to 17
                map.setZoom(HIGH_SPEED_ZOOM, {
                    animate: true,
                    duration: ANIMATION_DURATION
                });
                autoZoomState.isZoomedOut = true;
                console.log(`Speed ${speed} mph > ${SPEED_THRESHOLD} mph - zooming out to ${HIGH_SPEED_ZOOM}`);
            }
            // Check if we need to zoom back in (slowed down)
            else if (speed <= SPEED_THRESHOLD && autoZoomState.isZoomedOut) {
                // Speed dropped below threshold - zoom back in to 18
                map.setZoom(NORMAL_ZOOM, {
                    animate: true,
                    duration: ANIMATION_DURATION
                });
                autoZoomState.isZoomedOut = false;
                console.log(`Speed ${speed} mph <= ${SPEED_THRESHOLD} mph - zooming in to ${NORMAL_ZOOM}`);
            }

            autoZoomState.lastSpeed = speed;
        }

        function updateDisplay() {
            if (!currentLocation) return;

            // Speed (convert m/s to mph)
            const speedMph = currentLocation.speed !== null ?
                (currentLocation.speed * 2.237).toFixed(0) : '--';
            document.getElementById('speed').textContent = speedMph;

            // Speed limit
            if (roadInfo && roadInfo.speedLimit) {
                const speedElement = document.getElementById('speed-limit');
                const currentSpeed = currentLocation.speed !== null ?
                    (currentLocation.speed * 2.237) : 0;

                // Add visual indicator if showing cached data
                const cachedIndicator = speedLimitCache.isCached ?
                    ' <span style="opacity: 0.6; font-size: 0.85em;">(cached)</span>' : '';

                // Color code based on current speed vs limit
                if (currentSpeed > roadInfo.speedLimit + 5) {
                    // Over speed limit by 5+ mph - orange warning
                    speedElement.innerHTML = `Limit <span style="color: #f97316;">${roadInfo.speedLimit}</span> mph${cachedIndicator}`;
                } else {
                    // Within speed limit - normal gray
                    speedElement.innerHTML = `Limit ${roadInfo.speedLimit} mph${cachedIndicator}`;
                }
            } else {
                document.getElementById('speed-limit').textContent = '--';
            }

            // Auto-zoom based on speed
            handleAutoZoom(speedMph);

            // Heading
            let heading = currentLocation.heading;

            // Calculate heading from movement if GPS heading not available
            if ((heading === null || heading === undefined) && previousLocation && currentLocation.speed > 1) {
                heading = calculateBearing(
                    previousLocation.lat,
                    previousLocation.lng,
                    currentLocation.lat,
                    currentLocation.lng
                );
            }

            if (heading !== null && heading !== undefined) {
                document.getElementById('heading').textContent = heading.toFixed(0);
                document.getElementById('direction').textContent = getCardinalDirection(heading);

                // Rotate arrow to point in heading direction
                const arrowElement = document.getElementById('heading-arrow');
                arrowElement.style.transform = `rotate(${heading}deg)`;
                arrowElement.style.opacity = '1';
            } else {
                document.getElementById('heading').textContent = '--';
                document.getElementById('direction').textContent = 'Stationary';

                // Dim arrow when stationary
                const arrowElement = document.getElementById('heading-arrow');
                arrowElement.style.opacity = '0.3';
            }

            // Accuracy (convert meters to feet) - inline in header
            const accuracyFt = (currentLocation.accuracy * 3.28084).toFixed(0);
            document.getElementById('accuracy-inline').textContent = `Â±${accuracyFt}ft`;

            // Altitude (convert meters to feet)
            if (currentLocation.altitude !== null) {
                const altitudeFt = (currentLocation.altitude * 3.28084).toFixed(0);
                document.getElementById('altitude').textContent = altitudeFt;
            } else {
                document.getElementById('altitude').textContent = '--';
            }

            // Coordinates - bottom left of map
            document.getElementById('map-coordinates').textContent =
                `${currentLocation.lat.toFixed(6)}, ${currentLocation.lng.toFixed(6)}`;

            // Road info
            if (roadInfo) {
                // ALWAYS show highway number if we have it, optionally add name in parentheses
                let roadName;

                if (roadInfo.highwayNumber) {
                    // Format the highway number (I25, US287, FM2499, etc.)
                    const formattedNumber = formatHighwayName(roadInfo.highwayNumber);

                    if (roadInfo.roadName) {
                        // Have both number and name: "I35E (Ronald Reagan Highway)"
                        roadName = `${formattedNumber} (${roadInfo.roadName})`;
                    } else {
                        // Just the number: "I35E", "FM2499"
                        roadName = formattedNumber;
                    }
                } else if (roadInfo.road) {
                    // No highway number, just show whatever road info we have
                    roadName = formatHighwayName(roadInfo.road);
                } else {
                    roadName = 'Unknown';
                }

                document.getElementById('road-name').textContent = roadName;
                document.getElementById('road-type').textContent =
                    `${roadInfo.type} â€¢ ${roadInfo.city}, ${roadInfo.state}`;
            }

            // Update weather display (for dynamic sunrise/sunset transitions)
            updateWeatherDisplay();
        }

        function updateExitsDisplay() {
            const exitsList = document.getElementById('exits-list');

            if (nearbyExits.length === 0) {
                exitsList.innerHTML = '<div class="no-data">No exits within 0.5 miles</div>';

                // Clear markers
                exitMarkers.forEach(marker => marker.remove());
                exitMarkers = [];
                return;
            }

            // Separate exits from entrances
            const exits = nearbyExits.filter(e => e.type === 'exit');
            const entrances = nearbyExits.filter(e => e.type === 'entrance');

            // Display exits
            let html = '';

            if (exits.length > 0) {
                html += '<div style="margin-bottom: 8px; font-size: 11px; color: #f97316; font-weight: 600;">EXITS</div>';
                html += exits.map(exit => `
                    <div class="exit-item">
                        <div class="exit-name" style="color: #f97316;">ðŸ”´ ${exit.name}</div>
                        <div class="exit-meta">
                            <span>ðŸ“ ${exit.distance.toFixed(2)} mi</span>
                            ${exit.destination ? `<span>â†’ ${exit.destination}</span>` : ''}
                        </div>
                    </div>
                `).join('');
            }

            if (entrances.length > 0) {
                if (exits.length > 0) html += '<div style="margin: 12px 0; border-top: 1px solid #3a3a3a;"></div>';
                html += '<div style="margin-bottom: 8px; font-size: 11px; color: #10b981; font-weight: 600;">ENTRANCES</div>';
                html += entrances.map(entrance => `
                    <div class="exit-item">
                        <div class="exit-name" style="color: #10b981;">ðŸŸ¢ ${entrance.name}</div>
                        <div class="exit-meta">
                            <span>ðŸ“ ${entrance.distance.toFixed(2)} mi</span>
                            ${entrance.destination ? `<span>â†’ ${entrance.destination}</span>` : ''}
                        </div>
                    </div>
                `).join('');
            }

            exitsList.innerHTML = html;

            // Update map markers
            exitMarkers.forEach(marker => marker.remove());
            exitMarkers = [];

            nearbyExits.slice(0, 5).forEach(exit => {
                // Different colors for exits vs entrances
                const isExit = exit.type === 'exit';
                const color = isExit ? '#f97316' : '#10b981';  // Orange for exits, green for entrances
                const label = isExit ? 'Exit' : 'Entrance';

                // Create custom marker element for MapLibre
                const exitEl = document.createElement('div');
                exitEl.className = 'exit-marker';
                exitEl.style.width = '12px';
                exitEl.style.height = '12px';
                exitEl.style.borderRadius = '50%';
                exitEl.style.backgroundColor = color;
                exitEl.style.border = '2px solid #ffffff';
                exitEl.style.boxShadow = '0 0 4px rgba(0,0,0,0.3)';
                exitEl.style.cursor = 'pointer';

                const marker = new maplibregl.Marker({
                    element: exitEl,
                    anchor: 'center'
                })
                .setLngLat([exit.lng, exit.lat]) // [lng, lat] - REVERSED!
                .setPopup(
                    new maplibregl.Popup({offset: 15})
                    .setHTML(`<strong>${label}: ${exit.name}</strong><br>${exit.distance.toFixed(2)} mi`)
                )
                .addTo(map);

                exitMarkers.push(marker);
            });
        }

        // ==================== STYLE CUSTOMIZATION ====================
        function toggleStyleEditor() {
            const content = document.getElementById('style-editor-content');
            const toggle = document.getElementById('style-editor-toggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = 'â–²';
            } else {
                content.style.display = 'none';
                toggle.textContent = 'â–¼';
            }
        }

        // Helper: Convert hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Helper: Convert RGB to hex
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // Helper: Determine if color is light or dark
        function isLightColor(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return false;
            // Calculate luminance using relative luminance formula
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            return luminance > 0.5;
        }

        // Helper: Generate gradient color (darker if light, lighter if dark)
        function generateGradientColor(baseColor, amount = 0.7) {
            const rgb = hexToRgb(baseColor);
            if (!rgb) return baseColor;

            const isLight = isLightColor(baseColor);
            const factor = isLight ? (1 - amount) : (1 + amount);

            let r = Math.round(rgb.r * factor);
            let g = Math.round(rgb.g * factor);
            let b = Math.round(rgb.b * factor);

            // Clamp values to 0-255
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            return rgbToHex(r, g, b);
        }

        // Helper: Apply color (no gradient for now)
        function createGradientExpression(baseColor, gradientColor) {
            // Just use the base color - no gradient
            return baseColor;
        }

        async function fetchAndCustomizeStyle(baseStyleURL, customColors) {
            try {
                const response = await fetch(baseStyleURL);
                const styleJSON = await response.json();

                // Generate gradient colors
                const highwayGradient = generateGradientColor(customColors.highway);
                const primaryGradient = generateGradientColor(customColors.primary);
                const streetGradient = generateGradientColor(customColors.street);
                const waterGradient = generateGradientColor(customColors.water);
                const waterwayGradient = generateGradientColor(customColors.waterway);
                const parkGradient = generateGradientColor(customColors.park);
                const backgroundGradient = generateGradientColor(customColors.background);

                console.log('Applying custom colors with gradients:', {
                    highway: customColors.highway + ' -> ' + highwayGradient,
                    primary: customColors.primary + ' -> ' + primaryGradient,
                    street: customColors.street + ' -> ' + streetGradient,
                    water: customColors.water + ' -> ' + waterGradient,
                    park: customColors.park + ' -> ' + parkGradient
                });

                let modifiedLayers = [];

                // Find and modify layers
                styleJSON.layers.forEach(layer => {
                    if (!layer.paint) return;

                    // Modify highway colors with gradient
                    if (layer.id.includes('road_mot') || layer.id.includes('motorway')) {
                        if (layer.paint['line-color']) {
                            const oldColor = layer.paint['line-color'];
                            layer.paint['line-color'] = createGradientExpression(customColors.highway, highwayGradient);
                            modifiedLayers.push(layer.id + ' (highway): ' + JSON.stringify(oldColor).substring(0, 50) + ' -> gradient');
                        }
                    }

                    // Modify primary road colors with gradient
                    if (layer.id.includes('road_pri') || layer.id.includes('primary')) {
                        if (layer.paint['line-color']) {
                            layer.paint['line-color'] = createGradientExpression(customColors.primary, primaryGradient);
                            modifiedLayers.push(layer.id + ' (primary)');
                        }
                    }

                    // Modify street colors with gradient (secondary, tertiary, residential roads)
                    if (layer.id.includes('road_sec') || layer.id.includes('secondary') ||
                        layer.id.includes('road_ter') || layer.id.includes('tertiary') ||
                        layer.id.includes('road_res') || layer.id.includes('residential') ||
                        layer.id.includes('road_min') || layer.id.includes('minor')) {
                        if (layer.paint['line-color']) {
                            layer.paint['line-color'] = createGradientExpression(customColors.street, streetGradient);
                            modifiedLayers.push(layer.id + ' (street)');
                        }
                    }

                    // Modify building colors (no gradient)
                    if (layer.id === 'building' || layer.id === 'building-top') {
                        if (layer.paint['fill-color']) {
                            layer.paint['fill-color'] = customColors.building;
                            modifiedLayers.push(layer.id + ' (building)');
                        }
                    }

                    // Modify water colors with gradient
                    if (layer.id === 'water') {
                        if (layer.paint['fill-color']) {
                            layer.paint['fill-color'] = createGradientExpression(customColors.water, waterGradient);
                            modifiedLayers.push(layer.id + ' (water)');
                        }
                    }

                    // Modify waterway colors with gradient
                    if (layer.id === 'waterway') {
                        if (layer.paint['line-color']) {
                            layer.paint['line-color'] = createGradientExpression(customColors.waterway, waterwayGradient);
                            modifiedLayers.push(layer.id + ' (waterway)');
                        }
                    }

                    // Modify park colors with gradient (parks, forests, green spaces)
                    if (layer.id.includes('park') || layer.id.includes('wood') ||
                        layer.id.includes('forest') || layer.id.includes('nature') ||
                        layer.id.includes('grass') || layer.id.includes('recreation')) {
                        if (layer.paint['fill-color']) {
                            layer.paint['fill-color'] = createGradientExpression(customColors.park, parkGradient);
                            modifiedLayers.push(layer.id + ' (park)');
                        }
                    }

                    // Modify background color with gradient (land)
                    if (layer.id === 'background' || layer.id === 'landcover' ||
                        layer.id === 'land' || layer.id.includes('landuse')) {
                        if (layer.paint['background-color']) {
                            layer.paint['background-color'] = createGradientExpression(customColors.background, backgroundGradient);
                            modifiedLayers.push(layer.id + ' (background-color)');
                        }
                        if (layer.paint['fill-color']) {
                            layer.paint['fill-color'] = createGradientExpression(customColors.background, backgroundGradient);
                            modifiedLayers.push(layer.id + ' (background-fill)');
                        }
                    }

                    // Modify text/label colors and size
                    if (layer.type === 'symbol') {
                        // Update text color
                        if (layer.paint && layer.paint['text-color']) {
                            layer.paint['text-color'] = customColors.text;
                        }
                        if (layer.paint && layer.paint['text-halo-color']) {
                            // Keep halo but adjust to contrast with new text color
                            layer.paint['text-halo-color'] = customColors.text === '#333333' ? '#FFFFFF' : '#000000';
                        }

                        // Update text size - recursively scale ALL text size values
                        if (layer.layout && customColors.textSize) {
                            const scaleFactor = customColors.textSize / 12;

                            // Recursive function to scale text sizes in nested expressions
                            const scaleTextSizeRecursive = (value, context = null) => {
                                // Handle simple number
                                if (typeof value === 'number') {
                                    // Only scale if it looks like a font size (6-100) and we're not in a zoom context
                                    if (context !== 'zoom' && value >= 6 && value <= 100) {
                                        return value * scaleFactor;
                                    }
                                    return value;
                                }

                                // Handle arrays
                                if (Array.isArray(value)) {
                                    // Check if this is an interpolate expression: ["interpolate", [...], ["zoom"], val1, val2, ...]
                                    if (value[0] === 'interpolate' && Array.isArray(value[2]) && value[2][0] === 'zoom') {
                                        // Scale only the odd-indexed values after position 3 (the size values, not zoom levels)
                                        return value.map((item, index) => {
                                            // Values at indices 4, 6, 8, 10... are sizes (odd positions after header)
                                            if (index > 3 && index % 2 === 0) {
                                                return scaleTextSizeRecursive(item, 'size');
                                            }
                                            return scaleTextSizeRecursive(item, index > 3 && index % 2 === 1 ? 'zoom' : null);
                                        });
                                    }
                                    // Regular array - recurse normally
                                    return value.map(item => scaleTextSizeRecursive(item, context));
                                }

                                // Handle objects
                                if (typeof value === 'object' && value !== null) {
                                    // Handle "stops" format: { "stops": [[zoom, size], [zoom, size]] }
                                    if (value.stops && Array.isArray(value.stops)) {
                                        return {
                                            ...value,
                                            stops: value.stops.map(stop => {
                                                if (Array.isArray(stop) && stop.length === 2) {
                                                    // stop[0] is zoom (don't scale), stop[1] is size (scale it)
                                                    return [stop[0], scaleTextSizeRecursive(stop[1], 'size')];
                                                }
                                                return stop;
                                            })
                                        };
                                    }
                                    // Regular object - recurse
                                    const scaled = {};
                                    for (const key in value) {
                                        scaled[key] = scaleTextSizeRecursive(value[key], context);
                                    }
                                    return scaled;
                                }

                                return value;
                            };

                            // Apply to text-size
                            if (layer.layout['text-size']) {
                                layer.layout['text-size'] = scaleTextSizeRecursive(layer.layout['text-size']);
                            }
                        }

                        // Force all text to be horizontal (not rotated along roads)
                        if (layer.layout) {
                            layer.layout['text-rotation-alignment'] = 'viewport';
                            layer.layout['text-pitch-alignment'] = 'viewport';
                        }
                    }
                });

                console.log('Modified layers:', modifiedLayers);
                console.log('Total layers modified:', modifiedLayers.length);

                return styleJSON;
            } catch (error) {
                console.error('Style fetch error:', error);
                throw error;
            }
        }

        async function applyCustomStyle() {
            const customColors = {
                highway: document.getElementById('color-highway').value,
                primary: document.getElementById('color-primary').value,
                street: document.getElementById('color-street').value,
                building: document.getElementById('color-building').value,
                water: document.getElementById('color-water').value,
                waterway: document.getElementById('color-waterway').value,
                park: document.getElementById('color-park').value,
                background: document.getElementById('color-background').value,
                text: document.getElementById('color-text').value,
                textSize: parseInt(document.getElementById('text-size-slider').value)
            };

            const currentStyle = localStorage.getItem('map_style') || 'voyager';
            const baseStyleURL = getVectorStyleURL(currentStyle);

            try {
                const customStyleJSON = await fetchAndCustomizeStyle(baseStyleURL, customColors);
                map.setStyle(customStyleJSON);

                map.once('styledata', () => {
                    loadRadar();
                });

                console.log('Custom style applied');
            } catch (error) {
                alert('Failed to apply custom style');
            }
        }

        function saveCustomStyle() {
            const customColors = {
                highway: document.getElementById('color-highway').value,
                primary: document.getElementById('color-primary').value,
                street: document.getElementById('color-street').value,
                building: document.getElementById('color-building').value,
                water: document.getElementById('color-water').value,
                waterway: document.getElementById('color-waterway').value,
                park: document.getElementById('color-park').value,
                background: document.getElementById('color-background').value,
                text: document.getElementById('color-text').value,
                textSize: document.getElementById('text-size-slider').value
            };

            localStorage.setItem('custom_style_colors', JSON.stringify(customColors));
            alert('Custom colors saved!');
        }

        function resetStyle() {
            // Reset to defaults
            document.getElementById('color-highway').value = '#FFA500';
            document.getElementById('color-primary').value = '#FFDD88';
            document.getElementById('color-street').value = '#FFFFFF';
            document.getElementById('color-building').value = '#E4DCD0';
            document.getElementById('color-water').value = '#B0D0D6';
            document.getElementById('color-waterway').value = '#CCE7EA';
            document.getElementById('color-park').value = '#C8E6C9';
            document.getElementById('color-background').value = '#F5F5F0';
            document.getElementById('color-text').value = '#333333';
            document.getElementById('text-size-slider').value = '12';
            document.getElementById('text-size-value').textContent = '12px';

            // Reload base style
            const currentStyle = localStorage.getItem('map_style') || 'voyager';
            map.setStyle(getVectorStyleURL(currentStyle));

            map.once('styledata', () => {
                loadRadar();
            });
        }

        // Load saved custom colors on init
        function loadSavedColors() {
            const saved = localStorage.getItem('custom_style_colors');
            if (saved) {
                const colors = JSON.parse(saved);
                document.getElementById('color-highway').value = colors.highway || '#FFA500';
                document.getElementById('color-primary').value = colors.primary || '#FFDD88';
                document.getElementById('color-street').value = colors.street || '#FFFFFF';
                document.getElementById('color-building').value = colors.building || '#E4DCD0';
                document.getElementById('color-water').value = colors.water || '#B0D0D6';
                document.getElementById('color-waterway').value = colors.waterway || '#CCE7EA';
                document.getElementById('color-park').value = colors.park || '#C8E6C9';
                document.getElementById('color-background').value = colors.background || '#F5F5F0';
                document.getElementById('color-text').value = colors.text || '#333333';

                const textSize = colors.textSize || '12';
                document.getElementById('text-size-slider').value = textSize;
                document.getElementById('text-size-value').textContent = textSize + 'px';
            }
        }

        // ==================== UTILITIES ====================
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 3959; // Earth radius in miles
            const dLat = toRad(lat2 - lat1);
            const dLng = toRad(lng2 - lng1);

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLng / 2) * Math.sin(dLng / 2);

            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLng = toRad(lng2 - lng1);
            const y = Math.sin(dLng) * Math.cos(toRad(lat2));
            const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                      Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLng);
            const bearing = Math.atan2(y, x);
            return (toDeg(bearing) + 360) % 360;
        }

        function toRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        function toDeg(radians) {
            return radians * (180 / Math.PI);
        }

        function getCardinalDirection(heading) {
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const index = Math.round(((heading % 360) / 45)) % 8;
            return directions[index];
        }

        function updateStatus(text, state) {
            document.getElementById('status-text').textContent = text;
            const dot = document.getElementById('status-dot');
            dot.className = 'status-indicator ' + state;
        }
    </script>
</body>
</html>
